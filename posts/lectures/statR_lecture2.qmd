---
title: "Язык программирования R для анализа данных: лекция 2"
author: "Елена Убогоева"
execute: 
  echo: true
format: 
  revealjs:
    slide-number: c/t
    # mainfont: Arial
    # fontsize: 14px
    theme: [default, custom.scss]
    # theme: [serif]
    # mouse-wheel: true
    auto-play-media: true
    width: 1280
    height: 720
editor: visual
draft: true
---

## Повторим материал предыдущей лекции

-   Переменные

-   Векторы

    -   Какие бывают типы векторов?

    -   Неявное и явное приведение типов

    -   Индексация векторов: по номеру индекса, логическим вектором

-   Логические операторы: И, ИЛИ, НЕ

-   Пропущенные значения:

    -   Поиск пропущенных значений

    -   Исключение пропущенных значений из вектора

::: callout-important
Важно! Значения в векторе могут быть **только** **одного** типа
:::

## План лекции

-   Матрицы

-   Списки

-   Датафреймы

-   Установка пакетов

-   Условия, циклы (и особенности их использования)

-   Векторизация как концепт, заменяющий циклы

## Взаимоотношение типов данных в R

::: columns
::: {.column width="50%"}
Матрицы и списки (lists) являются расширением векторов, в свою очередь датафреймы объединяют свойства матриц и списков.

Поэтому важно рассмотреть матрицы и списки перед разбором датафреймов.
:::

::: {.column width="50%"}
![](figures/matrix-list-df.png){width="468"}
:::
:::

## Матрицы

Почти такое же понимание как и в линейной алгебре.

::: columns
::: {.column width="50%"}
Создадим матрицу (укажем числа и количество строк):

```{r}
M <- matrix(1:20, nrow = 5)
M
```
:::

::: {.column width="50%"}
![](https://habrastorage.org/files/9ec/4ea/93a/9ec4ea93ab9a440e8a293a87df6dc303.gif){width="513"}
:::
:::

Можно сказать, что матрица - вектор, имеющий размерность 2 (строки и столбцы). Матрица, как и вектор, может содержать данные **только одного типа**. Бывают логические, числовые и строковые матрицы (последние редко).

## Индексация матриц

Для индексации используем квадратные скобки, матрицы имеют два измерения, следовательно, надо прописывать оба: `matrix[rows, columns]`

::: incremental
-   Поэлементное извлечение

    ```{r}
    M[1, 1] # извлечь элемент первой строки первого столбца матрицы
    M[3, 4] # извлечь элемент третьей строки четвертого столбца матрицы
    ```

-   Извлечь целую строку или столбец

    ```{r}
    M[1, ] # извлечь первую строку
    M[, 4] # извлечь четвертый столбец
    ```
:::

## Индексация матриц

Можно индексировать целыми векторами:

```{r}
M[1:3, ] # извлечь строки с первой по третью
M[1:2, 2:3] # извлечь элементы первой-второй строк второго и третьего столбца
```

```{r}
M[c(3, 1), ] # извлечь третью, первую строку
```

::: {.callout-note appearance="minimal"}
Правила индексации матриц нам очень понадобятся при работе с датафреймами
:::

## Замена элементов матриц

Также, как и при работе с векторами, часть элементов матрицы можно переписать.

Вспомним как для векторов:

```{r}
x <- 1:10
x[5] <- 100
x
```

```{r}
M[1:3, 2:4] <- 100
M
```

::: {.callout-note appearance="minimal"}
Матрицы, как тип данных, используются при создании тепловых карт.
:::

## Списки (lists)

Список в R может содержать данные разного типа, даже другие списки. Список можно создать функцией `list()`.

```{r}
list1 <- list(1:5, 'JoJo', TRUE)
list1
```

## Вложенные списки {style="font-size: 90%"}

```{r}
list_complex <- list(list1, c('this', 'is', 'complex list'))
list_complex
```

Обычно сложные вложенные списки никто намеренно не создает, но такой список может возникнуть например после парсинга сайтов или терминов генной онтологии.

::: {.callout-note appearance="simple"}
Парсинг - сбор и структурирование данных с последующим анализом.
:::

## Структура листа {.smaller}

У сложных списков удобно посмотреть структуру, используя функцию `str()`

```{r}
str(list_complex)

```

Можно создавать именованные списки:

```{r}
named_list <- list(names = c('Joseph', 'Jotaro'), 
                   part = c(2, 3))
named_list
```

## Индексация списков

Индексация списков устроена несколько сложнее, чем векторов и матриц.

::: columns
::: {.column width="40%"}
Для начала попробуем индексацию по номеру

```{r}

list1[1]
class(list1[1])
length(list1[1])
```

Получился список длиной 1. Как же извлечь элемент списка не в виде списка?
:::

::: {.column width="60%"}
Иллюстрация:

![Взято из твиттера [\@hadleywickham](https://twitter.com/hadleywickham)](https://i.stack.imgur.com/6Vwry.png){fig-align="left" width="629"}
:::
:::

## Индексация списков

Чтобы извлечь элемент списка не в виде списка можно использовать две квадратные скобки `sample_list[[1]]`.

```{r}
list1[[1]]
```

Также можно использовать индексацию по имени: используя знак `$` или имя элемента в квадратных скобках в кавычках.

```{r}
named_list$part
```

```{r}
named_list[['part']]
```

## Создание новых элементов списка

Удобнее всего создать новый элемент с помощью знака `$`

```{r}
named_list$year <- c(2012, 2014)
named_list
```

## Датафреймы

Датафреймы - прямоугольные таблицы, которые могут содержать данные **разного типа**. Нам понадобится много работать с датафреймами.

Попробуем создать датафрейм: функция `data.frame()`

```{r}
df <- data.frame(names = c('Alexandra', 'Vlad', 'Ekaterina'), 
                 year = c(5, 3, 6),
                 tasks = c(TRUE, FALSE, TRUE))
df

```

::: {.callout-important appearance="simple"}
Столбцы в датафрейме могут быть разных типов, однако в рамках одного столбца данные должны быть одного типа.
:::

## Индексация датафреймов

::: columns
::: {.column width="50%"}
Индексация датафреймов объединяет принципы индексации матриц и списков.
:::

::: {.column width="50%"}
![](figures/matrix-list-df.png)
:::
:::

## Индексация датафреймов как матриц

Используя квадратные скобки и индекс строк, колонок.

::: columns
::: {.column width="50%"}
Поэлементное извлечение:

```{r}
df[2, 1]
```

Извлечение конкретных строк и столбцов

```{r}
df[2:3, 1:2]
```
:::

::: {.column width="50%"}
Извлечь целые строки или столбцы:

```{r}
df[2, ]
df[, 3]
```
:::
:::

::: callout-tip
При расстановке пробелов пользуемся правилами пунктуации: пробел ставится после запятой.
:::

## Индексация датафреймов как списков

С помощью знака `$` или можно с помощью квадратных скобок

```{r}
df$names
df$year
df[['names']]
df$names == df[, 1]
```

## Создание новых колонок

Похоже на обращение к существующей, но пишем новое название и заполняем значениями.

```{r}
df$email <- c('email1', 'email2', 'email3')
df
```

Подробнее про работу с датафреймами еще поговорим в лекции по `tidyverse`.

## Установка пакетов

Пакеты с CRAN-а скачиваются командой `install.packages('название пакета')`.

```{r}
#| eval: false
install.packages('tidyverse')
```

После того, как мы скачали пакет, его необходимо подгружать каждый раз при работе командой `library(название пакета)`

```{r}
library(tidyverse)
```

Иногда можно подгрузить одну функцию из пакета, используя оператор `::`

```{r}
#| eval: false
dplyr::case_when(<выражение>) # про это чуть дальше
```

## Установка пакетов не из CRAN

-   С github-a или других репозиториев. Используется пакет `remotes`.

    ```{r}
    #| eval: false
    remotes::install_github('ggpattern')
    ```

-   С [биокондактора](https://www.bioconductor.org/install/). Сначала нужно установить сам bioconductor - менеджер биологических пакетов.

    ```{r}
    #| eval: false
    if (!require("BiocManager", quietly = TRUE))
        install.packages("BiocManager")
    ```

    Далее устанавливаем нужный пакет, хранящийся в биокондакторе:

    ```{r}
    #| eval: false
    BiocManager::install(c("GenomicFeatures", "DESeq2"))
    ```

## Условные конструкции: `if`

Синтаксис условной конструкции: `if (condition) true_action`

```{r}
number <- 10
if (number > 0) print('Положительное число')
```

Если выражение содержит несколько строчек, то необходимо использовать фигурные скобки.

```{r}
number <- 10
if (number > 0) {
  print('Положительное число')
}
```

## Условные конструкции: `if`, `else`

Для описания действий в случае не выполнения условия используется оператор `else`

`if (condition) true_action else false_action`

```{r}
random_number <- sample(-5:5, 1) # чтобы извлечь случайное число 
# из набора чисел от -5 до 5
random_number
if (random_number > 0) {
  print('Положительное число')
} else {
  print('Отрицательное число или ноль')
}
```

::: {.callout-important appearance="simple"}
Поскольку команды в R исполняются построчно, важно, чтобы оператор `else` был на той же строке, что и закрывающая фигурная скобка `if`.
:::

## Векторизованный `if`

Оператор `if` на вход принимает только одно число. Что делать, если нам нужно проверить на какое-то условие целый вектор?

Вот это работать не будет (начиная с версии R 4.0):

```{r}
#| error: true
if (-3:3 > 0) print('Положительное число')
```

Для операции над векторами используем функцию `ifelse()` из base R или `if_else()` из библиотеки `dplyr`.

```{r}
x <- 2:11
ifelse(x %% 2 == 0, 'Четное число', 'Нечетное число')
```

## `if_else()` из библиотеки dplyr

Отличается чуть большей строгостью. Например, нельзя смешивать данные разных типов. Синтаксис такой же, как и в обычном `ifelse()`.

```{r}
dplyr::if_else(2:11 %% 2 == 0, 'Четное', 'Нечетное')
```

Что произойдет, если мы используем разный тип данных для выражений выполненного условия и невыполненного?

::: columns
::: {.column width="50%"}
```{r}
#| error: true
library(dplyr)
if_else(-3:3 == 0, 0, 'Не ноль')
```
:::

::: {.column width="50%"}
```{r}
ifelse(-3:3 == 0, 0, 'Не ноль')
```
:::
:::

Значения, в случае, если условие выполнилось, и если не выполнилось, должны быть одного типа.

## Оператор `case_when()`

Если условий больше двух (или даже больше одного), на помощь приходит функция `case_when()` из пакета `dplyr`.

```{r}
dplyr::case_when(x > 0 ~ 'Положительное число', 
                 x == 0 ~ 'Ноль', 
                 x < 0 ~ 'Отрицательное число')
```

Здесь тоже работает требование об одинаковом типе данных на значения после выполнения условия.

Про пакет `dplyr` поговорим подробнее в лекции 4 про `tidyverse`.

## Циклы

Циклы в R не рекомендованы к использованию, однако знать их синтаксис не повредит.

Синтаксис:

```{r}
#| eval: false
for (item in vector) {
  <набор действий>
}
```

::: columns
::: {.column width="50%"}
Например:

```{r}
for (i in 1:6) {
  print(i ^ 2)
}
```
:::

::: {.column width="50%"}
Конечно, возведение в степень куда проще сделать без цикла, но это учебный пример:

```{r}
(1:6) ^ 2
```
:::
:::

## Как использовать циклы правильно? {style="font-size: 90%"}

Одна из частых ошибок новичков при написании циклов - попасться в ловушку копирования.

Допустим, мы написали цикл, в котором на каждой итерации вектор увеличивается на 1 элемент. В R каждый раз происходит копирование и выделение нового места под вектор и это *extremely slow*.

Нужно заранее создать вектор нужного размера, чтобы выделить для него память и не создавать копий (подробнее [здесь](https://adv-r.hadley.nz/perf-measure.html#memory-profiling), [здесь](https://adv-r.hadley.nz/perf-improve.html#avoid-copies)).

Плохо:

```{r}
#| code-line-numbers: "|2,4"
values <- 11:20
cube_values <- vector()
for (i in 1:length(values)) {
  cube_values <- c(cube_values, values[i] ^ 3) # копирование на каждой итерации
}
cube_values
```

------------------------------------------------------------------------

::: columns
::: {.column width="50%"}
Лучше создать вектор нужного размера перед циклом:

```{r}
#| code-line-numbers: "|1,2"
cube_values <- vector('numeric', 
  length = length(values)) 
for (i in 1:length(values)) {
  cube_values[i] <- values[i] ^ 3
}
cube_values
```
:::

::: {.column width="50%"}
Совсем правильно использовать `seq_along():`

```{r}
#| code-line-numbers: "|3"
cube_values <- vector(mode = 'numeric', 
                      length = length(values))
for (i in seq_along(values)) {
  cube_values[i] <- values[i] ^ 3
}
cube_values
```
:::
:::

Рекомендуется использовать `seq_along()`, чтобы наверняка избежать проблемы с пустым вектором.

Правильно конечно с точки зрения циклов, так как есть ряд альтернативных рекомендуемых подходов вместо них.

::: callout-tip
Совет от Соника: не использовать циклы вообще👍
:::

## Как использовать циклы правильно?

Вторая распространенная ошибка: проблема с `1:length(vector)`

Суть в том, что мы можем получить неожиданный результат, если вектор пустой, поскольку оператор `:` работает и в убывающую сторону (то есть получается 1:0).

```{r}
empty_vector <- vector()
for (i in 1:length(empty_vector)) {
  print(i ^ 2)
}
```

Похоже, что мы ожидали не этого. Чтобы этого избежать, вместо `1:length()` используем `seq_along()`.

```{r}
for (i in seq_along(empty_vector)) {
  print(i ^ 2)
}
```

## Векторизация - вместо циклов

Вообще правильный подход - использовать векторизацию вместо циклов.

Векторизация - это применение какой-либо функции над каждым элементом вектора.

Можно записать идею в математической нотации:

Пусть *f()* - векторизованная функция. Тогда $y = f(x)$ означает, что мы применяем функцию *f()* к каждому элементу вектора `x`, на выходе получаем вектор `y` такой же длины как вектор `x`.

```{r}
vectorized_example <- 1:10
sqrt(vectorized_example)
```

::: {.callout-note appearance="simple"}
Фраза *векторизованная функция* означает, что операции производятся сразу над каждым элементом вектора.
:::

## Еще немного векторизации

Большинство базовых функций в R векторизованы по умолчанию, и если они применимы к одному элементу, то скорее всего будут применимы и к целому вектору. Например, уже разобранные операторы возведения в степень `^`, квадратный корень, логарифм и тд.

```{r}
(1:10) ^ 2
log(1:10, 2)
```

Не являются векторизованными: `mean()`, `sum()`. Как думаете, почему?

```{r}
mean(1:100)
sum(1:100)
```

## Применение векторизации {style="font-size: 90%"}

Например, нам нужно посчитать средние значения в списке, а функция `mean()` не векторизована. Что делать? Использовать функции семейства `*apply()`.

```{r}
list_values <- list(rnorm(10), rnorm(10, mean = 5, sd = 2),
                    rnorm(10, mean = 10, sd = 3))
list_values

```

::: {.callout-note appearance="simple"}
`rnorm()` генерирует числа из нормального распределения со среднем 0 и стандартным отклонением 1 (по умолчанию).
:::

------------------------------------------------------------------------

```{r}
#| output-location: default
lapply(list_values, mean)
```

## Спасибо за внимание!

::: columns
::: {.column width="50%"}
Подписывайтесь на телеграм-канал о статистике:

![](images/image-650896138.png){width="440"}
:::
:::
