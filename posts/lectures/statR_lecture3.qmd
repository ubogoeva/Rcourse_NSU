---
title: "Язык программирования R для анализа данных: лекция 3"
author: "Елена Убогоева"
execute: 
  echo: true
format: 
  revealjs:
    slide-number: c/t
    # mainfont: Arial
    theme: [default, custom.scss]
    # theme: [serif]
    # mouse-wheel: true
    auto-play-media: true
    width: 1280
    height: 720
revealjs-plugins:
  - pointer
editor: visual
draft: true
---

## Повторим материал предыдущей лекции

-   Матрицы, списки, датафреймы

-   Условия и циклы

-   Основы векторизации

## План лекции

-   Операции над векторами разной длины, ресайклинг.

-   Создание собственных функций.

-   Семейство функций `*apply()`.

-   Импорт и экспорт данных в R.

-   Описательные статистики

## Операции над векторами

Что произойдет в результате выполнения этого кода?

```{r}
vector1 <- c(1, 1, 2, 3, 5, 8)
vector2 <- c(2, 3, 5, 8, 13, 21)
vector1 + vector2
```

Произойдет поэлементное сложение каждого элемента первого вектора с элементами второго вектора.

Можно проводить любые операции над векторами одной длины: сложение, вычитание, умножение, возведение в степень и тд. Это очень полезно и является одним из преимуществ R для анализа данных.

Что произойдет, если провести подобные операции над векторами разной длины?

## Операции над векторами разной длины

Теперь представим, что векторы у нас разной длины, попробуем сделать сложение и вычитание:

::: columns
::: {.column width="50%"}
```{r}
long_vector <- c(1, 1, 2, 3, 5, 8)
short_vector <- c(2, 3, 5)

long_vector + short_vector
```

```{r}
long_vector - short_vector
```
:::

::: {.column width="50%"}
![](images/image-74450106.png){width="444"}
:::
:::

Значения вектора меньшего размера как бы переиспользуются (recycling) для значений вектора большего.

## Ресайклинг одного значения {style="font-size: 80%"}

Можно умножить вектор на какое-то значение (такое задание уже было в домашней работе). Здесь тоже сработает правило ресайклинга: единственное значение вектора переиспользуется каждый раз.

```{r}
long_vector * 3
long_vector ^ 2
```

Тоже самое для логических операций:

```{r}
long_vector == 3
long_vector > 2
```

И даже (хотя такое не рекомендуется):

```{r}
long_vector == short_vector
```

## Что произойдет при ресайклинге некратных векторов?

Для проверки длины векторов можно использовать функцию `length()`

```{r}
#| warning: true
vector2 <- c(3, 5, 1, 4)
length(long_vector)
length(vector2)
long_vector - vector2
```

Ресайклинг некратных векторов не рекомендуется к использованию из-за непредсказуемости аутпута.

## Зачем нужен ресайклинг векторов?

-   ~~Чтобы удивлять друзей~~

-   Наиболее полезен ресайклинг одного значения, например, чтобы сделать преобразование.\
    `x / mean(x)`, `x / 1000000`

-   Обращать внимание, если ресайклинг произошел не так, как было задумано.

## Pitfalls - подводные камни при ресайклинге

-   Нужно знать о правилах ресайклинга, чтобы понять, почему что-то может получиться не так, как было задумано. Допустим, у нас есть вектор с различными значениями, и мы хотим извлечь определенные, попробуем использовать оператор `==`:

```{r}
eyes <- c('green', 'blue', 'black', 'blue', 'green', 'green')
eyes[eyes == c('green', 'blue')]
```

Вроде все правильно. Или все же нет?

Здесь сработало правило ресайклинга, которое привело к неправильному результату без уведомлений об ошибке, что особенно неприятно

::: incremental
-   

    ```{r}
    eyes == c('green', 'blue')
    ```
:::

## Оператор `%in%` для проверки наличия элементов вектора

Правильно проверять, есть ли элементы в векторе, нужно с помощью оператора `%in%`, в который можно подать целый вектор значений.

```{r}
eyes %in% c('green', 'blue')
eyes[eyes %in% c('green', 'blue')]
```

## Полезные функции для работы с векторами {style="font-size: 90%"}

Иногда бывает полезно извлечь *индексы* элементов `TRUE` логического вектора, тогда можно использовать функцию `which()`.

```{r}
eyes %in% c('green', 'blue')
which(eyes %in% c('green', 'blue'))
```

Вообще перевод логического вектора в числовой для индексации может повысить производительность, если в векторе очень мало `TRUE` и размер вектора измеряется в десятках тысяч. Подробнее можно почитать [здесь](https://adv-r.hadley.nz/subsetting.html?q=recycling#boolean-algebra-versus-sets-logical-and-integer).

Однако вот такая запись избыточна:

```{r}
eyes[which(eyes %in% c('green', 'blue'))]
# достаточно использовать логическую индексацию
eyes[eyes %in% c('green', 'blue')]
```

## Полезные функции для работы с векторами

Для проверки, есть ли хоть один `TRUE` в векторе используется функция `any()`, для проверки, все ли значения в векторе `TRUE`, есть функция `all()`.

::: columns
::: {.column width="50%"}
```{r}
any(c(FALSE, TRUE, FALSE, FALSE))
any(c(FALSE, FALSE, FALSE))

```
:::

::: {.column width="50%"}
```{r}
all(c(FALSE, TRUE, FALSE, FALSE))
all(c(TRUE, TRUE, TRUE))
```
:::
:::

## Создание собственных функций

Нередко возникает ситуация, когда нужно проделать одну и ту же операцию несколько раз. В таком случае есть смысл написать свою функцию. Действует [правило трех](https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)): если понадобилось скопировать один и тот же кусочек кода три раза, подумайте о создании функции.

Преимущества написания функций:

-   Способ избежать ошибок copy-paste, например, есть риск не поменять название переменной в одном месте.

-   Если необходимо поменять какой-то параметр, то достаточно поменять в функции один раз, а не каждый раз при вызове этого кода.

-   Можно давать функции понятное название, что облегчит восприятие и читаемость кода.

## Пример собственной функции

Функции пишутся по шаблону:

```{r}
#| eval: false
name <- function(arguments) {
  body
}
```

Например, создадим функцию, которая возводит заданное число в заданную степень.

```{r}
pow <- function(value, p) {
  power <- value ^ p
  return(power)
}
pow(11, 4)
```

## Написание своих функций {style="font-size: 90%"}

-   Когда функция встречает ключевое слово `return`, выполнение функции прекращается и возвращается подсчитанное значение (все, что после `return` будет проигнорировано).

-   Ключевое слово `return` можно не использовать, тогда функция вернет последнее вычисленное значение (если последним действием было не присваивание).

```{r}
# вот так работать не будет
pow <- function(x, p) {
  power <- x ^ p
}
pow(11, 4)
```

::: columns
::: {.column width="50%"}
```{r}
# а так будет
pow <- function(x, p) {
  x ^ p
}
pow(11, 4)
```
:::

::: {.column width="50%"}
```{r}
pow <- function(x, p) {
  power <- x ^ p
  power
}
pow(11, 4)
```
:::
:::

## Рекомендации по написанию функций

-   `return` все же рекомендуется к использованию, чтобы повысить читаемость кода.

-   Необходимо давать фукциям понятные названия, обычно советуют использовать глаголы.

-   Для функций, которые планируется использовать не только для себя, рекомендуется прописать проверку входных значений и обработку исключений.

Почитать можно детальнее [здесь](https://adv-r.hadley.nz/functions.html#functions) (на английском) и [здесь](https://textbook.rintro.ru/functions.html) (на русском).

## Позиционные и именованные аргументы

Как многие могли заметить для встроенных функций в R, иногда мы задаем в явном виде названия аргументов, а иногда полагаемся на порядок.

```{r}
rep(c(10, 15), 2) # вариант по умолчанию
rep(c(10, 15), times = 2)
rep(c(10, 15), each = 2) # вариант с использованием each
rep(x = c(10, 15), times = 2, each = 2)
rep(each = 2, times = 2, x = c(10, 15)) # аргументы в другом порядке, но заданы по именам
```

## Создание своей полезной функции {style="font-size: 90%"}

Попробуем создать полезную функцию, вычисляющую моду - наиболее часто встречающееся значение в выборке. Здесь будут полезны функции `table()` и `which.max()` - возвращает индекс максимального значения

```{r}
set.seed(42) # чтобы случайное семплирование воспроизводилось
x <- sample(1:5, 15, replace = TRUE)
x
calculate_mode <- function(x) {
  if (is.character(x)) {
    return(names(table(x)[which.max(table(x))]))
  }
  return(as.numeric(names(table(x)[which.max(table(x))])))
}
calculate_mode(x)
calculate_mode(c('a', 'b', 'a', 'a', 'c', 'd'))
```

## Простые числа

```{r}
is_prime <- function(x) {
  if (x == 1) return(FALSE)
  if (x == 2) return(2)
  if (sum(x %% 2:(x-1) == 0) == 0) return(x) else return(FALSE)
}
```

## Локальное и глобальное окружение {style="font-size: 85%"}

При создании функции у нее есть свое собственное окружение (локальное). В этом локальном окружении существуют переменные функции.

Есть глобальное окружение, в котором обычно хранятся созданные переменные. Если функция не находит нужную переменную в локальном окружении, то она отправляется их искать в предыдущем окружении - в общем случае в глобальном.

```{r}
y <- 10
func1 <- function(x) {
  y + x ^ 2
}
func1(10)
```

Однако это не является хорошей практикой, всегда рекомендуется создавать переменные внутри функции и не надеяться на глобальное окружение.

Созданные переменные внутри функции не попадают в глобальное окружение.

## Аргументы по умолчанию

Нередко встречается ситуация, когда какой-то аргумент функции используется чаще других. В таком случае есть смысл задать аргумент по умолчанию, например в функции `sort()`, по умолчанию аргумент `decreasing = FALSE`, следовательно, функция сортирует по возрастанию.

```{r}
sort(c(1, 4, 2, -1, 10, 5))
sort(c(1, 4, 2, -1, 10, 5), decreasing = TRUE)
```

Можно самостоятельно задавать их для своих функций.

## Ленивые вычисления (lazy evaluation)

Аргументы функции могут не использоваться, если их не вызвать эксплицитно, поскольку в R есть концепция *ленивых вычислений*.

```{r}
lazy_function <- function(value, arg_never_used) {
  return(value ^ 2) 
}
lazy_function(10)
```

Ленивые вычисления позволяют обращаться к переменной, только если ее использование необходимо.

## Функциональное программирование - функция `apply()`

Сама функция `apply()` применяется к матрицам или многомерным массивам. Можно применить `apply()` к датафрейму, но он сначала превратится в матрицу.

Например, задача посчитать среднее по всем столбцам матрицы.

Синтаксис: `apply(array, margin, function)`, где `margin` - измерение, по которому будет итерироваться функция `function`, 1 - это строки, 2 - столбцы.

```{r}
M <- matrix(1:20, nrow = 4)
M

```

## Функциональное программирование - функция `apply()`

```{r}
apply(M, 1, mean) # подсчет среднего по строкам
apply(M, 2, mean) # подсчет среднего по столбцам

```

Попробуем применить `apply()` к датафрейму `mtcars`

```{r}
apply(mtcars, 2, mean) # по столбцам
```

::: callout-important
## Обратите внимание!

Здесь функция `mean` без круглых скобок, поскольку используется не сама функция, а название функции является аргументом функции `apply()`.
:::

## Семейство функций `*apply()`

Существует целый зоопарк сходных функций: lapply, vapply, sapply, tapply, mapply, однако на практике чаще используется `lapply`, а также функции семейства `map*()` из библиотеки `purrr`.

Наиболее полезная функция `lapply()` (от слов *list apply*), которая принимает на вход вектор или лист и выполняет заданную функцию.

```{r}
lapply(list(rnorm(10), 
            rnorm(10, sd = 2), rnorm(10, sd = 5)), sd)
```

## Используем свои функции в `apply()`

Давайте используем нашу простую функцию, которая вычисляет моду в данных.

```{r}
apply(iris, 2, calculate_mode)
```

```{r}
lapply(mtcars, calculate_mode)
```

## Анонимные функции

Анонимная функция - функция, которая создается и используется "на лету" в функциях `apply()`.

Распространенная практика использовать анонимные функции, если действие помещается в одну строчку.\
Синтаксис в `lapply()` такой: `function(i) <действие>,` где `i` - это i-тый элемент листа, для которого выполняется действие.

```{r}
lapply(11:20, function(i) rep(i, 10))
```

## Переходим от `*apply()` -\> `purrr::map_*()`

Часто можно встретить функцию `sapply()` (от слов *simplified apply*), которая упрощает выдачу. Однако в нынешней мете R не рекомендуется к использованию из-за непредсказуемости аутпута.

```{r}
sample_list <- list(rnorm(10), rnorm(10, sd = 2), rnorm(10, sd = 5))
sapply(sample_list, sd)
# сравните с lapply
lapply(sample_list, sd)
```

## Переходим от `*apply()` -\> `purrr::map_*()` {style="font-size: 85%"}

Чтобы контролировать формат аутпута используем функции семейства `map_*()` из библиотеки `purrr`.

В простом случае синтаксис `map()` не отличим от `lapply()`, аутпут всегда будет списком.

```{r}
library(purrr)
map(sample_list, sd)
```

Можно задать желаемый аутпут с помощью постфикса, например `map_chr()` - аутпут будет строковым вектором, `map_dbl()` - числовой вектор.

```{r}
map_dbl(sample_list, sd)
```

## Туториал по библиотеке `purrr`

Супер крутая презентация от Charlotte Wickham

[![](images/image-1680117827.png){fig-align="left" width="474"}](https://github.com/cwickham/purrr-tutorial/blob/master/slides.pdf)

Ссылка на [туториал](https://github.com/cwickham/purrr-tutorial/blob/master/slides.pdf)

## Импорт данных в R

Загрузка таблиц:

```{r}
#| eval: false
df <- read.table('путь/к/файлу/название_файла.txt')
```

Про организацию файлов для работы рекомендую почитать [здесь](R_setup.qmd).

Допустим, у нас лежит файл `wc3_units.txt` в директории `data`, попробуем его прочитать.

```{r}
df <- read.table('data/wc3_units.txt', sep = '\t', header = TRUE)
head(df)
```

## Посмотрим на данные {style="font-size: 80%"}

Удобно посмотреть, все ли прочитано корректно с помощью функции `str()`

```{r}
str(df)
```

Можно увидеть, что у нас почти все столбцы прочитались как строковые, это плохо для дальнейшей работы. Произошло это потому что пропущенное значение обозначено как `'-'`. Исправить можно разными способами, например заменить все значения в таблице и затем эксплицитно конвертировать столбцы в числовые, но проще всего поправить при чтении файла

## Еще раз прочитаем, но уже правильно

Для корректного чтения используем аргумент `na.strings`, в который запишем как в нашей таблице обозначены пропущенные значения

```{r}
#| layout-ncol: 2
df <- read.table('data/wc3_units.txt', sep = '\t', 
                 header = TRUE, na.strings = '-')
head(df)
str(df)
```

Теперь пропущенные значения обработались корректно.

## `summary()` - чтобы быстро оценить данные

Полезная функция, чтобы получить общее представление о данных.

```{r}
summary(df)
```

## Экспорт данных из R

Сохраним первые 15 строк датасета `mtcars` в файловую систему.

```{r}
write.table(mtcars[1:5, ], 'mtcars.txt')
```

## Спасибо за поддержку

Напоминаю, что лекции будут продолжаться при наличии поддержки слушателей, поскольку официально курс никак не финансируется.

[Ссылка](https://www.tinkoff.ru/rm/ubogoeva.elena1/TSRBI31474) и куар код:

![](images/qrcode.png)
