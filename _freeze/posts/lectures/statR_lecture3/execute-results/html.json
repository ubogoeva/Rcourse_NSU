{
  "hash": "03a55c4b5d9d0896e17ac4d9a0425759",
  "result": {
    "markdown": "---\ntitle: \"Язык программирования R для анализа данных: лекция 3\"\nauthor: \"Елена Убогоева\"\nexecute: \n  echo: true\nformat: \n  revealjs:\n    slide-number: c/t\n    # mainfont: Arial\n    theme: [default, custom.scss]\n    # theme: [serif]\n    # mouse-wheel: true\n    auto-play-media: true\n    width: 1280\n    height: 720\nrevealjs-plugins:\n  - pointer\neditor: visual\ndraft: true\n---\n\n\n## Повторим материал предыдущей лекции\n\n-   Матрицы, списки, датафреймы\n\n-   Условия и циклы\n\n-   Основы векторизации\n\n## План лекции\n\n-   Операции над векторами разной длины, ресайклинг.\n\n-   Создание собственных функций.\n\n-   Семейство функций `*apply()`.\n\n-   Импорт и экспорт данных в R.\n\n-   Описательные статистики\n\n## Операции над векторами\n\nЧто произойдет в результате выполнения этого кода?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector1 <- c(1, 1, 2, 3, 5, 8)\nvector2 <- c(2, 3, 5, 8, 13, 21)\nvector1 + vector2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  4  7 11 18 29\n```\n:::\n:::\n\n\nПроизойдет поэлементное сложение каждого элемента первого вектора с элементами второго вектора.\n\nМожно проводить любые операции над векторами одной длины: сложение, вычитание, умножение, возведение в степень и тд. Это очень полезно и является одним из преимуществ R для анализа данных.\n\nЧто произойдет, если провести подобные операции над векторами разной длины?\n\n## Операции над векторами разной длины\n\nТеперь представим, что векторы у нас разной длины, попробуем сделать сложение и вычитание:\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector <- c(1, 1, 2, 3, 5, 8)\nshort_vector <- c(2, 3, 5)\n\nlong_vector + short_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  4  7  5  8 13\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector - short_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1 -2 -3  1  2  3\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n![](images/image-74450106.png){width=\"444\"}\n:::\n:::\n\nЗначения вектора меньшего размера как бы переиспользуются (recycling) для значений вектора большего.\n\n## Ресайклинг одного значения {style=\"font-size: 80%\"}\n\nМожно умножить вектор на какое-то значение (такое задание уже было в домашней работе). Здесь тоже сработает правило ресайклинга: единственное значение вектора переиспользуется каждый раз.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector * 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  3  6  9 15 24\n```\n:::\n\n```{.r .cell-code}\nlong_vector ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  1  4  9 25 64\n```\n:::\n:::\n\n\nТоже самое для логических операций:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector == 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nlong_vector > 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\nИ даже (хотя такое не рекомендуется):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector == short_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n:::\n\n\n## Что произойдет при ресайклинге некратных векторов?\n\nДля проверки длины векторов можно использовать функцию `length()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector2 <- c(3, 5, 1, 4)\nlength(long_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nlength(vector2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nlong_vector - vector2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in long_vector - vector2: длина большего объекта не является\nпроизведением длины меньшего объекта\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2 -4  1 -1  2  3\n```\n:::\n:::\n\n\nРесайклинг некратных векторов не рекомендуется к использованию из-за непредсказуемости аутпута.\n\n## Зачем нужен ресайклинг векторов?\n\n-   ~~Чтобы удивлять друзей~~\n\n-   Наиболее полезен ресайклинг одного значения, например, чтобы сделать преобразование.\\\n    `x / mean(x)`, `x / 1000000`\n\n-   Обращать внимание, если ресайклинг произошел не так, как было задумано.\n\n## Pitfalls - подводные камни при ресайклинге\n\n-   Нужно знать о правилах ресайклинга, чтобы понять, почему что-то может получиться не так, как было задумано. Допустим, у нас есть вектор с различными значениями, и мы хотим извлечь определенные, попробуем использовать оператор `==`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\neyes <- c('green', 'blue', 'black', 'blue', 'green', 'green')\neyes[eyes == c('green', 'blue')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"green\" \"blue\"  \"blue\"  \"green\"\n```\n:::\n:::\n\n\nВроде все правильно. Или все же нет?\n\nЗдесь сработало правило ресайклинга, которое привело к неправильному результату без уведомлений об ошибке, что особенно неприятно\n\n::: incremental\n-   \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    eyes == c('green', 'blue')\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE\n    ```\n    :::\n    :::\n\n:::\n\n## Оператор `%in%` для проверки наличия элементов вектора\n\nПравильно проверять, есть ли элементы в векторе, нужно с помощью оператора `%in%`, в который можно подать целый вектор значений.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neyes %in% c('green', 'blue')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\neyes[eyes %in% c('green', 'blue')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"green\" \"blue\"  \"blue\"  \"green\" \"green\"\n```\n:::\n:::\n\n\n## Полезные функции для работы с векторами {style=\"font-size: 90%\"}\n\nИногда бывает полезно извлечь *индексы* элементов `TRUE` логического вектора, тогда можно использовать функцию `which()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neyes %in% c('green', 'blue')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nwhich(eyes %in% c('green', 'blue'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 4 5 6\n```\n:::\n:::\n\n\nВообще перевод логического вектора в числовой для индексации может повысить производительность, если в векторе очень мало `TRUE` и размер вектора измеряется в десятках тысяч. Подробнее можно почитать [здесь](https://adv-r.hadley.nz/subsetting.html?q=recycling#boolean-algebra-versus-sets-logical-and-integer).\n\nОднако вот такая запись избыточна:\n\n\n::: {.cell}\n\n```{.r .cell-code}\neyes[which(eyes %in% c('green', 'blue'))]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"green\" \"blue\"  \"blue\"  \"green\" \"green\"\n```\n:::\n\n```{.r .cell-code}\n# достаточно использовать логическую индексацию\neyes[eyes %in% c('green', 'blue')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"green\" \"blue\"  \"blue\"  \"green\" \"green\"\n```\n:::\n:::\n\n\n## Полезные функции для работы с векторами\n\nДля проверки, есть ли хоть один `TRUE` в векторе используется функция `any()`, для проверки, все ли значения в векторе `TRUE`, есть функция `all()`.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nany(c(FALSE, TRUE, FALSE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nany(c(FALSE, FALSE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nall(c(FALSE, TRUE, FALSE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nall(c(TRUE, TRUE, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n:::\n\n## Создание собственных функций\n\nНередко возникает ситуация, когда нужно проделать одну и ту же операцию несколько раз. В таком случае есть смысл написать свою функцию. Действует [правило трех](https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)): если понадобилось скопировать один и тот же кусочек кода три раза, подумайте о создании функции.\n\nПреимущества написания функций:\n\n-   Способ избежать ошибок copy-paste, например, есть риск не поменять название переменной в одном месте.\n\n-   Если необходимо поменять какой-то параметр, то достаточно поменять в функции один раз, а не каждый раз при вызове этого кода.\n\n-   Можно давать функции понятное название, что облегчит восприятие и читаемость кода.\n\n## Пример собственной функции\n\nФункции пишутся по шаблону:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- function(arguments) {\n  body\n}\n```\n:::\n\n\nНапример, создадим функцию, которая возводит заданное число в заданную степень.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npow <- function(value, p) {\n  power <- value ^ p\n  return(power)\n}\npow(11, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14641\n```\n:::\n:::\n\n\n## Написание своих функций {style=\"font-size: 90%\"}\n\n-   Когда функция встречает ключевое слово `return`, выполнение функции прекращается и возвращается подсчитанное значение (все, что после `return` будет проигнорировано).\n\n-   Ключевое слово `return` можно не использовать, тогда функция вернет последнее вычисленное значение (если последним действием было не присваивание).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# вот так работать не будет\npow <- function(x, p) {\n  power <- x ^ p\n}\npow(11, 4)\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# а так будет\npow <- function(x, p) {\n  x ^ p\n}\npow(11, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14641\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npow <- function(x, p) {\n  power <- x ^ p\n  power\n}\npow(11, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14641\n```\n:::\n:::\n\n:::\n:::\n\n## Рекомендации по написанию функций\n\n-   `return` все же рекомендуется к использованию, чтобы повысить читаемость кода.\n\n-   Необходимо давать фукциям понятные названия, обычно советуют использовать глаголы.\n\n-   Для функций, которые планируется использовать не только для себя, рекомендуется прописать проверку входных значений и обработку исключений.\n\nПочитать можно детальнее [здесь](https://adv-r.hadley.nz/functions.html#functions) (на английском) и [здесь](https://textbook.rintro.ru/functions.html) (на русском).\n\n## Позиционные и именованные аргументы\n\nКак многие могли заметить для встроенных функций в R, иногда мы задаем в явном виде названия аргументов, а иногда полагаемся на порядок.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(10, 15), 2) # вариант по умолчанию\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 15 10 15\n```\n:::\n\n```{.r .cell-code}\nrep(c(10, 15), times = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 15 10 15\n```\n:::\n\n```{.r .cell-code}\nrep(c(10, 15), each = 2) # вариант с использованием each\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 10 15 15\n```\n:::\n\n```{.r .cell-code}\nrep(x = c(10, 15), times = 2, each = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 10 15 15 10 10 15 15\n```\n:::\n\n```{.r .cell-code}\nrep(each = 2, times = 2, x = c(10, 15)) # аргументы в другом порядке, но заданы по именам\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 10 15 15 10 10 15 15\n```\n:::\n:::\n\n\n## Создание своей полезной функции {style=\"font-size: 90%\"}\n\nПопробуем создать полезную функцию, вычисляющую моду - наиболее часто встречающееся значение в выборке. Здесь будут полезны функции `table()` и `which.max()` - возвращает индекс максимального значения\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42) # чтобы случайное семплирование воспроизводилось\nx <- sample(1:5, 15, replace = TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 5 1 1 2 4 2 2 1 4 1 5 4 2 2\n```\n:::\n\n```{.r .cell-code}\ncalculate_mode <- function(x) {\n  if (is.character(x)) {\n    return(names(table(x)[which.max(table(x))]))\n  }\n  return(as.numeric(names(table(x)[which.max(table(x))])))\n}\ncalculate_mode(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ncalculate_mode(c('a', 'b', 'a', 'a', 'c', 'd'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n:::\n\n\n## Простые числа\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_prime <- function(x) {\n  if (x == 1) return(FALSE)\n  if (x == 2) return(2)\n  if (sum(x %% 2:(x-1) == 0) == 0) return(x) else return(FALSE)\n}\n```\n:::\n\n\n## Локальное и глобальное окружение {style=\"font-size: 85%\"}\n\nПри создании функции у нее есть свое собственное окружение (локальное). В этом локальном окружении существуют переменные функции.\n\nЕсть глобальное окружение, в котором обычно хранятся созданные переменные. Если функция не находит нужную переменную в локальном окружении, то она отправляется их искать в предыдущем окружении - в общем случае в глобальном.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 10\nfunc1 <- function(x) {\n  y + x ^ 2\n}\nfunc1(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 110\n```\n:::\n:::\n\n\nОднако это не является хорошей практикой, всегда рекомендуется создавать переменные внутри функции и не надеяться на глобальное окружение.\n\nСозданные переменные внутри функции не попадают в глобальное окружение.\n\n## Аргументы по умолчанию\n\nНередко встречается ситуация, когда какой-то аргумент функции используется чаще других. В таком случае есть смысл задать аргумент по умолчанию, например в функции `sort()`, по умолчанию аргумент `decreasing = FALSE`, следовательно, функция сортирует по возрастанию.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(c(1, 4, 2, -1, 10, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1  1  2  4  5 10\n```\n:::\n\n```{.r .cell-code}\nsort(c(1, 4, 2, -1, 10, 5), decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10  5  4  2  1 -1\n```\n:::\n:::\n\n\nМожно самостоятельно задавать их для своих функций.\n\n## Ленивые вычисления (lazy evaluation)\n\nАргументы функции могут не использоваться, если их не вызвать эксплицитно, поскольку в R есть концепция *ленивых вычислений*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlazy_function <- function(value, arg_never_used) {\n  return(value ^ 2) \n}\nlazy_function(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n:::\n\n\nЛенивые вычисления позволяют обращаться к переменной, только если ее использование необходимо.\n\n## Функциональное программирование - функция `apply()`\n\nСама функция `apply()` применяется к матрицам или многомерным массивам. Можно применить `apply()` к датафрейму, но он сначала превратится в матрицу.\n\nНапример, задача посчитать среднее по всем столбцам матрицы.\n\nСинтаксис: `apply(array, margin, function)`, где `margin` - измерение, по которому будет итерироваться функция `function`, 1 - это строки, 2 - столбцы.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- matrix(1:20, nrow = 4)\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n```\n:::\n:::\n\n\n## Функциональное программирование - функция `apply()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(M, 1, mean) # подсчет среднего по строкам\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  9 10 11 12\n```\n:::\n\n```{.r .cell-code}\napply(M, 2, mean) # подсчет среднего по столбцам\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2.5  6.5 10.5 14.5 18.5\n```\n:::\n:::\n\n\nПопробуем применить `apply()` к датафрейму `mtcars`\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(mtcars, 2, mean) # по столбцам\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       mpg        cyl       disp         hp       drat         wt       qsec \n 20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n        vs         am       gear       carb \n  0.437500   0.406250   3.687500   2.812500 \n```\n:::\n:::\n\n\n::: callout-important\n## Обратите внимание!\n\nЗдесь функция `mean` без круглых скобок, поскольку используется не сама функция, а название функции является аргументом функции `apply()`.\n:::\n\n## Семейство функций `*apply()`\n\nСуществует целый зоопарк сходных функций: lapply, vapply, sapply, tapply, mapply, однако на практике чаще используется `lapply`, а также функции семейства `map*()` из библиотеки `purrr`.\n\nНаиболее полезная функция `lapply()` (от слов *list apply*), которая принимает на вход вектор или лист и выполняет заданную функцию.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(list(rnorm(10), \n            rnorm(10, sd = 2), rnorm(10, sd = 5)), sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1.630584\n\n[[2]]\n[1] 2.312116\n\n[[3]]\n[1] 5.576344\n```\n:::\n:::\n\n\n## Используем свои функции в `apply()`\n\nДавайте используем нашу простую функцию, которая вычисляет моду в данных.\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(iris, 2, calculate_mode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n       \"5.0\"        \"3.0\"        \"1.4\"        \"0.2\"     \"setosa\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(mtcars, calculate_mode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mpg\n[1] 10.4\n\n$cyl\n[1] 8\n\n$disp\n[1] 275.8\n\n$hp\n[1] 110\n\n$drat\n[1] 3.07\n\n$wt\n[1] 3.44\n\n$qsec\n[1] 17.02\n\n$vs\n[1] 0\n\n$am\n[1] 0\n\n$gear\n[1] 3\n\n$carb\n[1] 2\n```\n:::\n:::\n\n\n## Анонимные функции\n\nАнонимная функция - функция, которая создается и используется \"на лету\" в функциях `apply()`.\n\nРаспространенная практика использовать анонимные функции, если действие помещается в одну строчку.\\\nСинтаксис в `lapply()` такой: `function(i) <действие>,` где `i` - это i-тый элемент листа, для которого выполняется действие.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(11:20, function(i) rep(i, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] 11 11 11 11 11 11 11 11 11 11\n\n[[2]]\n [1] 12 12 12 12 12 12 12 12 12 12\n\n[[3]]\n [1] 13 13 13 13 13 13 13 13 13 13\n\n[[4]]\n [1] 14 14 14 14 14 14 14 14 14 14\n\n[[5]]\n [1] 15 15 15 15 15 15 15 15 15 15\n\n[[6]]\n [1] 16 16 16 16 16 16 16 16 16 16\n\n[[7]]\n [1] 17 17 17 17 17 17 17 17 17 17\n\n[[8]]\n [1] 18 18 18 18 18 18 18 18 18 18\n\n[[9]]\n [1] 19 19 19 19 19 19 19 19 19 19\n\n[[10]]\n [1] 20 20 20 20 20 20 20 20 20 20\n```\n:::\n:::\n\n\n## Переходим от `*apply()` -\\> `purrr::map_*()`\n\nЧасто можно встретить функцию `sapply()` (от слов *simplified apply*), которая упрощает выдачу. Однако в нынешней мете R не рекомендуется к использованию из-за непредсказуемости аутпута.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_list <- list(rnorm(10), rnorm(10, sd = 2), rnorm(10, sd = 5))\nsapply(sample_list, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8622293 2.4225496 3.4741834\n```\n:::\n\n```{.r .cell-code}\n# сравните с lapply\nlapply(sample_list, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.8622293\n\n[[2]]\n[1] 2.42255\n\n[[3]]\n[1] 3.474183\n```\n:::\n:::\n\n\n## Переходим от `*apply()` -\\> `purrr::map_*()` {style=\"font-size: 85%\"}\n\nЧтобы контролировать формат аутпута используем функции семейства `map_*()` из библиотеки `purrr`.\n\nВ простом случае синтаксис `map()` не отличим от `lapply()`, аутпут всегда будет списком.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nmap(sample_list, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.8622293\n\n[[2]]\n[1] 2.42255\n\n[[3]]\n[1] 3.474183\n```\n:::\n:::\n\n\nМожно задать желаемый аутпут с помощью постфикса, например `map_chr()` - аутпут будет строковым вектором, `map_dbl()` - числовой вектор.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(sample_list, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8622293 2.4225496 3.4741834\n```\n:::\n:::\n\n\n## Туториал по библиотеке `purrr`\n\nСупер крутая презентация от Charlotte Wickham\n\n[![](images/image-1680117827.png){fig-align=\"left\" width=\"474\"}](https://github.com/cwickham/purrr-tutorial/blob/master/slides.pdf)\n\nСсылка на [туториал](https://github.com/cwickham/purrr-tutorial/blob/master/slides.pdf)\n\n## Импорт данных в R\n\nЗагрузка таблиц:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.table('путь/к/файлу/название_файла.txt')\n```\n:::\n\n\nПро организацию файлов для работы рекомендую почитать [здесь](R_setup.qmd).\n\nДопустим, у нас лежит файл `wc3_units.txt` в директории `data`, попробуем его прочитать.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.table('data/wc3_units.txt', sep = '\\t', header = TRUE)\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Unit  Race Gold Wood Pop  HP Armor.Type Armor Sight Speed Time\n1  Peasant Human   75    0   1 220     Medium     0    80   190   15\n2  Militia Human    -    -   1 220      Heavy     4   140   270    -\n3  Footman Human  135    0   2 420      Heavy     2   140   270   20\n4 Rifleman Human  205   30   3 535     Medium     0   140   270   26\n5   Knight Human  245   60   4 835      Heavy     5   140   350   45\n6   Priest Human  135   10   2 290  Unarmored     0   140   270   28\n  Ground.Attack Damage Cooldown   DPS Range Air.Attack Damage.1 Cooldown.1\n1        Normal   5.50     2.00  2.75     0          -        -          -\n2        Normal  12.50     1.20 10.42     0          -        -          -\n3        Normal  12.50     1.35  9.26     0          -        -          -\n4        Pierce  21.00     1.50 14.00    40     Pierce    21.00       1.50\n5        Normal  34.00     1.40 24.29     0          -        -          -\n6         Magic   8.50     2.00  4.25    60      Magic     8.50       2.00\n  DPS.1 Range.1\n1     -       -\n2     -       -\n3     -       -\n4 14.00      60\n5     -       -\n6  4.25      60\n```\n:::\n:::\n\n\n## Посмотрим на данные {style=\"font-size: 80%\"}\n\nУдобно посмотреть, все ли прочитано корректно с помощью функции `str()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t71 obs. of  21 variables:\n $ Unit         : chr  \"Peasant\" \"Militia\" \"Footman\" \"Rifleman\" ...\n $ Race         : chr  \"Human\" \"Human\" \"Human\" \"Human\" ...\n $ Gold         : chr  \"75\" \"-\" \"135\" \"205\" ...\n $ Wood         : chr  \"0\" \"-\" \"0\" \"30\" ...\n $ Pop          : chr  \"1\" \"1\" \"2\" \"3\" ...\n $ HP           : int  220 220 420 535 835 290 325 600 200 360 ...\n $ Armor.Type   : chr  \"Medium\" \"Heavy\" \"Heavy\" \"Medium\" ...\n $ Armor        : chr  \"0\" \"4\" \"2\" \"0\" ...\n $ Sight        : int  80 140 140 140 140 140 140 140 180 140 ...\n $ Speed        : chr  \"190\" \"270\" \"270\" \"270\" ...\n $ Time         : chr  \"15\" \"-\" \"20\" \"26\" ...\n $ Ground.Attack: chr  \"Normal\" \"Normal\" \"Normal\" \"Pierce\" ...\n $ Damage       : chr  \"5.50\" \"12.50\" \"12.50\" \"21.00\" ...\n $ Cooldown     : chr  \"2.00\" \"1.20\" \"1.35\" \"1.50\" ...\n $ DPS          : chr  \"2.75\" \"10.42\" \"9.26\" \"14.00\" ...\n $ Range        : chr  \"0\" \"0\" \"0\" \"40\" ...\n $ Air.Attack   : chr  \"-\" \"-\" \"-\" \"Pierce\" ...\n $ Damage.1     : chr  \"-\" \"-\" \"-\" \"21.00\" ...\n $ Cooldown.1   : chr  \"-\" \"-\" \"-\" \"1.50\" ...\n $ DPS.1        : chr  \"-\" \"-\" \"-\" \"14.00\" ...\n $ Range.1      : chr  \"-\" \"-\" \"-\" \"60\" ...\n```\n:::\n:::\n\n\nМожно увидеть, что у нас почти все столбцы прочитались как строковые, это плохо для дальнейшей работы. Произошло это потому что пропущенное значение обозначено как `'-'`. Исправить можно разными способами, например заменить все значения в таблице и затем эксплицитно конвертировать столбцы в числовые, но проще всего поправить при чтении файла\n\n## Еще раз прочитаем, но уже правильно\n\nДля корректного чтения используем аргумент `na.strings`, в который запишем как в нашей таблице обозначены пропущенные значения\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\ndf <- read.table('data/wc3_units.txt', sep = '\\t', \n                 header = TRUE, na.strings = '-')\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Unit  Race Gold Wood Pop  HP Armor.Type Armor Sight Speed Time\n1  Peasant Human   75    0   1 220     Medium     0    80   190   15\n2  Militia Human   NA   NA   1 220      Heavy     4   140   270   NA\n3  Footman Human  135    0   2 420      Heavy     2   140   270   20\n4 Rifleman Human  205   30   3 535     Medium     0   140   270   26\n5   Knight Human  245   60   4 835      Heavy     5   140   350   45\n6   Priest Human  135   10   2 290  Unarmored     0   140   270   28\n  Ground.Attack Damage Cooldown   DPS Range Air.Attack Damage.1 Cooldown.1\n1        Normal    5.5     2.00  2.75     0       <NA>       NA         NA\n2        Normal   12.5     1.20 10.42     0       <NA>       NA         NA\n3        Normal   12.5     1.35  9.26     0       <NA>       NA         NA\n4        Pierce   21.0     1.50 14.00    40     Pierce     21.0        1.5\n5        Normal   34.0     1.40 24.29     0       <NA>       NA         NA\n6         Magic    8.5     2.00  4.25    60      Magic      8.5        2.0\n  DPS.1 Range.1\n1    NA      NA\n2    NA      NA\n3    NA      NA\n4 14.00      60\n5    NA      NA\n6  4.25      60\n```\n:::\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t71 obs. of  21 variables:\n $ Unit         : chr  \"Peasant\" \"Militia\" \"Footman\" \"Rifleman\" ...\n $ Race         : chr  \"Human\" \"Human\" \"Human\" \"Human\" ...\n $ Gold         : int  75 NA 135 205 245 135 155 215 90 180 ...\n $ Wood         : int  0 NA 0 30 60 10 20 30 30 70 ...\n $ Pop          : int  1 1 2 3 4 2 2 3 1 3 ...\n $ HP           : int  220 220 420 535 835 290 325 600 200 360 ...\n $ Armor.Type   : chr  \"Medium\" \"Heavy\" \"Heavy\" \"Medium\" ...\n $ Armor        : int  0 4 2 0 5 0 0 3 2 0 ...\n $ Sight        : int  80 140 140 140 140 140 140 140 180 140 ...\n $ Speed        : int  190 270 270 270 350 270 270 300 400 270 ...\n $ Time         : int  15 NA 20 26 45 28 30 28 13 40 ...\n $ Ground.Attack: chr  \"Normal\" \"Normal\" \"Normal\" \"Pierce\" ...\n $ Damage       : num  5.5 12.5 12.5 21 34 8.5 11 14 7.5 58 ...\n $ Cooldown     : num  2 1.2 1.35 1.5 1.4 2 1.75 1.9 2.5 3.5 ...\n $ DPS          : num  2.75 10.42 9.26 14 24.29 ...\n $ Range        : num  0 0 0 40 0 60 60 25 0 115 ...\n $ Air.Attack   : chr  NA NA NA \"Pierce\" ...\n $ Damage.1     : num  NA NA NA 21 NA 8.5 11 NA 14.5 NA ...\n $ Cooldown.1   : num  NA NA NA 1.5 NA 2 1.75 NA 2 NA ...\n $ DPS.1        : num  NA NA NA 14 NA 4.25 6.29 NA 7.25 NA ...\n $ Range.1      : num  NA NA NA 60 NA 60 60 NA 50 NA ...\n```\n:::\n:::\n\n\nТеперь пропущенные значения обработались корректно.\n\n## `summary()` - чтобы быстро оценить данные\n\nПолезная функция, чтобы получить общее представление о данных.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Unit               Race                Gold            Wood       \n Length:71          Length:71          Min.   : 60.0   Min.   :  0.00  \n Class :character   Class :character   1st Qu.:135.0   1st Qu.: 20.00  \n Mode  :character   Mode  :character   Median :190.0   Median : 30.00  \n                                       Mean   :195.6   Mean   : 39.06  \n                                       3rd Qu.:232.5   3rd Qu.: 60.00  \n                                       Max.   :425.0   Max.   :120.00  \n                                       NA's   :23      NA's   :23      \n      Pop              HP          Armor.Type            Armor       \n Min.   :0.000   Min.   :  75.0   Length:71          Min.   : 0.000  \n 1st Qu.:2.000   1st Qu.: 300.0   Class :character   1st Qu.: 0.000  \n Median :3.000   Median : 435.0   Mode  :character   Median : 1.000  \n Mean   :2.729   Mean   : 553.7                      Mean   : 1.257  \n 3rd Qu.:4.000   3rd Qu.: 700.0                      3rd Qu.: 2.000  \n Max.   :7.000   Max.   :1600.0                      Max.   :10.000  \n NA's   :12                                          NA's   :1       \n     Sight           Speed            Time      Ground.Attack     \n Min.   : 80.0   Min.   :190.0   Min.   :13.0   Length:71         \n 1st Qu.:120.0   1st Qu.:270.0   1st Qu.:24.0   Class :character  \n Median :140.0   Median :270.0   Median :30.0   Mode  :character  \n Mean   :135.9   Mean   :283.1   Mean   :32.8                     \n 3rd Qu.:140.0   3rd Qu.:320.0   3rd Qu.:40.0                     \n Max.   :190.0   Max.   :400.0   Max.   :65.0                     \n                 NA's   :1       NA's   :22                       \n     Damage          Cooldown          DPS            Range       \n Min.   :  5.50   Min.   :1.000   Min.   : 2.50   Min.   :  0.00  \n 1st Qu.: 12.50   1st Qu.:1.500   1st Qu.: 7.89   1st Qu.:  0.00  \n Median : 19.50   Median :1.750   Median :11.85   Median : 30.00  \n Mean   : 26.68   Mean   :1.902   Mean   :14.04   Mean   : 33.36  \n 3rd Qu.: 34.50   3rd Qu.:2.100   3rd Qu.:17.63   3rd Qu.: 51.25  \n Max.   :104.00   Max.   :4.500   Max.   :48.57   Max.   :115.00  \n NA's   :4        NA's   :3       NA's   :4       NA's   :3       \n  Air.Attack           Damage.1       Cooldown.1        DPS.1       \n Length:71          Min.   : 7.50   Min.   :1.050   Min.   : 3.570  \n Class :character   1st Qu.:12.00   1st Qu.:1.500   1st Qu.: 7.415  \n Mode  :character   Median :18.00   Median :1.750   Median :11.140  \n                    Mean   :25.59   Mean   :1.733   Mean   :15.510  \n                    3rd Qu.:32.75   3rd Qu.:2.000   3rd Qu.:20.415  \n                    Max.   :89.00   Max.   :3.000   Max.   :50.950  \n                    NA's   :36      NA's   :36      NA's   :36      \n    Range.1     \n Min.   : 0.00  \n 1st Qu.:35.00  \n Median :50.00  \n Mean   :44.64  \n 3rd Qu.:60.00  \n Max.   :60.00  \n NA's   :36     \n```\n:::\n:::\n\n\n## Экспорт данных из R\n\nСохраним первые 15 строк датасета `mtcars` в файловую систему.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.table(mtcars[1:5, ], 'mtcars.txt')\n```\n:::\n\n\n## Спасибо за поддержку\n\nНапоминаю, что лекции будут продолжаться при наличии поддержки слушателей, поскольку официально курс никак не финансируется.\n\n[Ссылка](https://www.tinkoff.ru/rm/ubogoeva.elena1/TSRBI31474) и куар код:\n\n![](images/qrcode.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}