{
  "hash": "f3587eb99bfd0587023e79264858d560",
  "result": {
    "markdown": "---\ntitle: \"Язык программирования R для анализа данных: лекция 1\"\nauthor: \"Елена Убогоева\"\nexecute: \n  echo: true\nformat: \n  revealjs:\n    slide-number: c/t\n    # mainfont: Arial\n    # fontsize: 14px\n    theme: [default, custom.scss]\n    # theme: [serif]\n    # mouse-wheel: true\n    auto-play-media: true\n    width: 1280\n    height: 720\neditor: visual\ndraft: true\n---\n\n\n## Обо мне\n\n::: columns\n::: {.column width=\"50%\"}\n**Образование:**\n\n-   Аспирантура ИЦиГ СО РАН, биоинформатика, 2020 - настоящее время\n\n-   Магистратура НГУ, факультет естественных наук, кафедра цитологии и генетики, 2018 - 2020\n\n-   Бакалавриат НГУ, факультет естественных наук, кафедра цитологии и генетики, 2014 - 2018\n:::\n\n::: {.column width=\"50%\"}\n**Опыт преподавания (избранное):**\n\n-   Технический ассистент на курсах бластим \"Статистика, R и анализ данных\" июнь 2022, октябрь 2022\n\n-   Преподаватель семинаров по курсу \"Компьютерная транскриптомика\" в магистратуре НГУ, кафедра биоинформатики, 2020-2021\n\n-   Преподаватель курса в Сириусе, направление \"Математическое моделирование в биологии развития растений\", апрель 2022\n:::\n:::\n\n## Информация о курсе\n\n::: columns\n::: {.column width=\"50%\"}\n-   12 лекций по одной лекции в неделю:\\\n    в воскресенье в 12, возможно в четверг в 19.00\n\n-   Домашние задания\n\n-   Итоговый проект\n\n-   С зачетными единицами пока не ясно, возможно удасться договориться с ПМ Бородиным, чтобы мой курс мог засчитаться\n:::\n\n::: {.column width=\"40%\"}\n-   Поддержать можно по ссылке\n\n    ![](images/qrcode.png)\n:::\n:::\n\n## Установка R и RStudio и начало работы\n\n-   [Скачать](https://cran.r-project.org/bin/windows/base/) и установить свежую версию R с официального сайта (CRAN);\n\n-   [Скачать](https://posit.co/download/rstudio-desktop/#download) и установить IDE RStudio;\n\n-   Больше рекомендаций и решений возможных проблем при установке можно почитать [здесь](https://ubogoeva.github.io/Rcourse_NSU/posts/welcome/how_to_install_R.html);\n\n-   Advanced: [настройка](https://telegra.ph/R-how-to-organize-work-08-08) проектов и лайфхаки при работе в RStudio.\n\n## Рекомендуемая литература\n\n::: columns\n::: {.column width=\"65%\"}\nБольшая часть литературы по R на английском, однако начинают появляться в том числе материалы на русском.\n\n-   [R4DataScience](https://r4ds.hadley.nz/) - книга для старта изучения R (Hadley Wickham).\n\n-   [Advanced R](https://adv-r.hadley.nz/) - для продвинутых пользователей, которые хотят разобраться больше в устройстве языка (Hadley Wickham).\n\n-   [Анализ данных и статистика в R](https://pozdniakov.github.io/tidy_stats/index.html) (автор Иван Поздняков).\n\n-   [Введение в язык программирования R](https://textbook.rintro.ru/index.html) (автор Филипп Управителев)\n\n-   Больше литературы [здесь](https://t.me/stats_for_science/25) и [здесь](https://t.me/r_in_action/61)\n:::\n\n::: {.column width=\"35%\"}\n![](https://d33wubrfki0l68.cloudfront.net/b88ef926a004b0fce72b2526b0b5c4413666a4cb/24a30/cover.png){fig-align=\"right\" width=\"364\"}\n:::\n:::\n\n## План лекции\n\n-   История языка\n\n-   Особенности архитектуры\n\n-   Переменные\n\n-   Векторы:\n\n    -   Типы векторов\n\n    -   Индексация векторов\n\n    -   Неявное и явное приведение типов\n\n-   Логические операторы, булева алгебра\n\n-   Работа с пропущенными значениями\n\n## История языка R\n\n::: {#.incremental .incremental}\n-   R - язык программирования для статистической обработки данных и визуализации результатов (Википедия).\n\n-   На самом деле R является языком широкого использования, например, с его помощью можно делать сайты, интерактивные приложения (shiny), презентации, писать книги и научные статьи.\n\n-   R является наследником языка S, который был создан в отделе статистики AT&T в её исследовательском подразделении Bell Labs в 1976 году.\n\n-   R был создан в 1991 в департаменте статистики Университета Окленда, Новая Зеландия. Разработчиками R поддерживается [CRAN](https://cran.r-project.org/) - репозиторий R-пакетов.\n\n-   Для анализа данных есть набор пакетов `tidyverse`, главный разработчик Hadley Wickham.\n\n-   Для работы с биологическими данными есть репозиторий [Bioconductor](https://www.bioconductor.org/).\n:::\n\n------------------------------------------------------------------------\n\n![](images/image-1997806000.png)\n\n-   [iDEP](http://bioinformatics.sdstate.edu/idep96/) - shiny app для анализа дифференциальной экспрессии генов\n\n-   [shinyGO](http://bioinformatics.sdstate.edu/go/) - shiny app для функциональной аннотации списков генов\n\n## Особенности архитектуры языка\n\nR - высокоуровневый интерпретируемый мультипарадигменный язык программирования.\n\n-   Парадигмы программирования:\n\n    -   императивное (процедурное)\n\n    -   функциональное\n\n    -   объект-ориентированное\n\n-   Типизация:\n\n    -   динамическая - не нужно заранее определять тип переменной и тип может меняться в процессе скрипта\n\n    -   нестрогая - происходит неявное приведение типов\n\n## R как калькулятор\n\nЛюбая книга по базовому R начинается с этого раздела, так что не будем нарушать традицию:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n40 + 2 # сложение\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 42\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n20 - 2 # вычитание\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n42 * 2 # умножение\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n42 / 2 # деление\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n2 ^ 4 # возведение в степень\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n:::\n\n\n## R как калькулятор\n\nФункции для арифметических операторов: `sqrt()`, `log()`\n\n::: incremental\n-   Квадратный корень\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sqrt(16) # квадратный корень, от слова square root\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 4\n    ```\n    :::\n    :::\n\n\n-   Логарифм\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    log(2) # по какому основанию логарифм?\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0.6931472\n    ```\n    :::\n    :::\n\n\n-   По умолчанию натуральный логарифм, то есть основание `e`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    log(exp(1)) # по умолчанию натуральный логарифм\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1\n    ```\n    :::\n    :::\n\n:::\n\n------------------------------------------------------------------------\n\nМожно задать основание логарифма. Как это сделать, можно узнать, вызвав справку функции `?log`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(x = 8, base = 2) # логарифм от числа 8 по основанию 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlog2(x = 8) # тоже логарифм от 8 по основанию 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n# есть также отдельная функция для десятичного логарифма\nlog10(1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n::: {.callout-tip appearance=\"simple\"}\nДля вызова справки можно использовать `?<название функции>,` `help(\"<название функции>\")` или нажать F1 на функции\n:::\n\n## Переменные\n\nПоскольку R является в первую очередь императивным языком программирования, то переменные и оператор присваивания занимают центральную роль. В качестве оператора присваивания используется `<-`.\n\nМожно набрать в RStudio, используя комбинацию клавиш `Alt -` (альт минус) или `Option -` на Mac.\n\nРавно `=` тоже будет работать, но не рекомендуется к использованию.\n\nПопробуем создать переменные:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- x + 5\n```\n:::\n\n\nПочему ничего не появилось в консоли в качестве аутпута?\n\n::: {.callout-note appearance=\"simple\"}\nРавно используется для подачи аргументов в функции: `log(x = 8, base = 2)`\n:::\n\n## Переменные\n\nПри создании переменной результат сохраняется и не выводится в консоль, если нам нужно узнать значение переменной, то можно использовать `print(x)` или просто набрать `x` в консоли.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\nТакже можно посмотреть на переменные во вкладке environment в правом верхнем углу RStudio\n\n## Переменные {style=\"font-size: 90%\"}\n\nС точки зрения компьютера в нем создается объект `10`, с которым связывается название переменной `x`. Переменные могут содержать все что угодно: числа, строки, датафреймы.\n\nПри создании переменных есть определенные правила:\n\n-   В названии можно использовать латиницу (строчные и заглавные буквы), нижнее подчеркивание (`_`), точки, цифры;\n\n-   нельзя использовать пробелы в названиях переменных;\n\n-   нельзя использовать зарезервированные слова, например, `TRUE`, `FALSE`, `if`, `function`, с полным списком можно ознакомиться, вызвав `?Reserved`.\n\nВ R для разделения длинных имен рекомендуется использовать нижнее подчеркивание, например: `data_processed`. Главное - последовательность в стиле написания кода.\n\n::: {.callout-tip appearance=\"simple\"}\nПодробнее про рекомендуемый стиль написания кода можно почитать [здесь](https://style.tidyverse.org/syntax.html)\n:::\n\n## Логические операторы\n\n::: columns\n::: {.column width=\"50%\"}\nМожно проверять на равенство переменные:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ny == 15\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nНе путаем операторы сравнения `==` и присваивания `=` (еще одна причина не использовать равно как оператор присваивания).\n:::\n\n::: {.column width=\"50%\"}\n![](https://pozdniakov.github.io/tidy_stats/images/WaCM5x3mvQM.jpg)\n:::\n:::\n\n## Логические операторы\n\n::: columns\n::: {.column width=\"50%\"}\nЧтобы проверить на неравенство используем оператор `!=`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical1 <- x != y\nlogical1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nlogical2 <- x != 10\nlogical2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nЕще можно сравнивать больше-меньше:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx > y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nx < y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n:::\n\nВосклицательный знак означает логическое НЕ (отрицание)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n!FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Еще немного булевой алгебры\n\nЛогическое И: выдаст `TRUE`, если все значения `TRUE`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical1 & logical2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nЛогическое ИЛИ: будет `TRUE`, если хотя бы одно из значений `TRUE`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical1 | logical2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Векторы\n\nВекторы являются ключевым типом данных в R, на основе которых строятся более сложные структуры данных. Скаляры (одиночные значения) являются векторами длиной 1.\n\nВектор - набор данных одного типа. В R существует 4 основных часто использующихся типов векторов.\n\nОсновные типы векторов:\n\n-   Логические, logical: `TRUE`, `FALSE`\n\n-   Целочисленные, integer: `1L`, `190L`\n\n-   Дробные, double или с плавающей точкой: `-1.5`, `0.05`, `5`. Еще есть `Inf`, `-Inf`, `NaN`\n\n-   Строковые, character: `'Hello world'`, `'character'`\n\n::: {.callout-note appearance=\"minimal\"}\nЦелочисленные вектора сопровождаются знаком `L` и не содержат дробной части\n:::\n\n## Создание векторов {style=\"font-size: 90%\"}\n\n-   с помощью функции `c()`. Например: `x <- c(5, 4, 5, 3, 2)`.\\\n    `gene_names <- c('ARR1', 'ARF19', 'WOX5')`\n\n-   с помощью двоеточия `:`, чтобы создавать набор чисел по порядку с шагом 1. Например:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    16:30\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n    ```\n    :::\n    :::\n\n\n-   с помощью `seq()`, если нужна последовательность чисел, с шагом, отличным от единицы\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    seq(from = 2, to = 20, by = 2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1]  2  4  6  8 10 12 14 16 18 20\n    ```\n    :::\n    :::\n\n\n-   с помощью `rep()` для создания повторяющихся элементов:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rep(c(1:3, 5), times = 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] 1 2 3 5 1 2 3 5 1 2 3 5\n    ```\n    :::\n    :::\n\n\n## Индексация векторов\n\nВ R индексация начинается с единицы (по-человечески). Для индексации используются квадратные скобки:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_vector <- 11:20\nsample_vector[1] # извлечь первый элемент вектора\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n\nДля извлечения нескольких элементов вектора в качестве индекса используется тоже вектор:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_vector[2:5] # извлечь элементы со второго по пятый\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12 13 14 15\n```\n:::\n\n```{.r .cell-code}\nsample_vector[c(3:6, 1, 10)] # извлечь элементы с третьего по шестой, первый и десятый\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13 14 15 16 11 20\n```\n:::\n:::\n\n\n## Индексация векторов\n\nМожно с помощью индексации заменять элементы:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_vector[2] <- 0\nsample_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11  0 13 14 15 16 17 18 19 20\n```\n:::\n:::\n\n\n::: callout-tip\nКруглые скобки используются при работе с функциями, квадратные при индексации\n:::\n\n## Индексация векторов с помощью условия\n\nКроме индексации по номеру, можно извлечь элементы вектора, соответствующие какому-либо условию.\n\nНапример, извлечь все значения, которые больше или равны нулю вектора `x`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -3:3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3 -2 -1  0  1  2  3\n```\n:::\n:::\n\n\nСначала используем условие:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx >= 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\nПолучаем логический вектор, который можно использовать как индекс для отбора нужных элементов `x`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x >= 0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 2 3\n```\n:::\n:::\n\n\n## Индексация векторов: проверка на четность {.smaller}\n\n::: incremental\n-   Допустим, у нас есть вектор `vect_for_even`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vect_for_even <- sample(1:100, 10)\n    vect_for_even\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] 26 96 18 94 33 38 78 25  6 47\n    ```\n    :::\n    :::\n\n\n    Задача вывести все четные элементы, используя знания об индексации векторов. Оператор остатка от деления: `%%`\n\n-   Это решается без циклов. Сначала делаем проверку условия, что остаток от деления на два каждого элемента равен нулю:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vect_for_even %% 2 == 0\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE\n    ```\n    :::\n    :::\n\n\n-   Далее используем полученный логический вектор в качестве индекса к исходному:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vect_for_even[vect_for_even %% 2 == 0]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 26 96 18 94 38 78  6\n    ```\n    :::\n    :::\n\n:::\n\n## Динамическая нестрогая типизация\n\n::: columns\n::: {.column width=\"50%\"}\n-   Динамическая: не нужно при создании вектора указывать его тип, как бывает в языках со статичной типизацией. Также тип вектора может поменяться в процессе кода:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vect <- seq(3, 11, 2)\n    vect\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]  3  5  7  9 11\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    vect <- 'Hello world'\n    ```\n    :::\n\n\n-   Нестрогая (слабая, weak): происходит неявное приведение типов\n:::\n\n::: {.column width=\"50%\"}\n![](images/image-1659150438.png){width=\"716\"}\n:::\n:::\n\n::: {.callout-note appearance=\"simple\"}\nR на этой картинке должен быть в левом нижнем углу\n:::\n\n## Неявное приведение типов\n\n::: incremental\n-   Векторы в R по определению могут быть только одного типа. Что произойдет, если мы попытаемся объединить в одном векторе элементы разных типов?\n\n    Например так:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(10, TRUE, FALSE)\n    ```\n    :::\n\n\n    Будет ли ошибка или каким-то образом произойдет объединение?\n\n-   Ответ:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 10  1  0\n    ```\n    :::\n    :::\n\n\n-   Произошло неявное приведение типов (*implicit coercion*): логический тип превратился в числа, `TRUE -> 1`, `FALSE -> 0`\n:::\n\n## Порядок неявного приведения типов\n\nЛогика порядка приведения типов: от менее общего к более общему\n\nlogical -\\> integer -\\> numeric -\\> character\n\nЧасто происходит превращение числового вектора в строку.\n\nПолезный пример неявного приведения типов: подсчет суммы истинных значений логического вектора\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1:10 > 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nset.seed(1)\np_val <- c(0.03, sample(seq(0.00001, 1, length.out = 100), 10))\np_val\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0300000 0.6767709 0.3838445 0.0000100 0.3333400 0.8686882 0.4242482\n [8] 0.1313218 0.8181836 0.5858627 0.5050555\n```\n:::\n\n```{.r .cell-code}\nsum(p_val < 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n## Неявное приведение типов: иллюстрация\n\n![](images/implicit_coercion_horizontal.png){width=\"545\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3, 4, 5, '6')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\"\n```\n:::\n:::\n\n\n## Проверка типа вектора\n\nЧтобы проверить тип вектора, можно использовать функцию `class()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5, '6')\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nТакже можно использовать функции проверки вектора на нужный тип: `is.numeric()`, `is.character()`, `is.logical()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.character(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\nЧтобы ознакомиться со списком функций `is.*` можно набрать `is.` в консоли и нажать Tab\n:::\n\n## Явное приведение типов\n\nЧтобы превратить вектор в нужный тип можно использовать функции: `as.numeric()`, `as.character()`, `as.logical()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n:::\n\n\nСоздадим вектор, который содержит строки и превратим в numeric обратно\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchar_vector <- c(1:6, 'seven')\nchar_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"     \"2\"     \"3\"     \"4\"     \"5\"     \"6\"     \"seven\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(char_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  2  3  4  5  6 NA\n```\n:::\n:::\n\n\n## Пропущенные значения\n\nПри работе с данными могут быть пропущенные значения в силу разных причин. В R обозначается `NA` - Not Available\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_missed <- c(1:10, NA)\nvector_missed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 NA\n```\n:::\n:::\n\n\nПроблема пропущенных значений: неопределенность \"заражает\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(vector_missed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmean(vector_missed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nАргумент `na.rm` - способ вычислить среднее (сумму и тп) без учета пропущенных значений\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(vector_missed, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n:::\n\n\n## Как находить пропущенные значения?\n\n::: incremental\n-   Давайте попробуем сравнить значения нашего вектора с `NA`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vector_missed == NA\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] NA NA NA NA NA NA NA NA NA NA NA\n    ```\n    :::\n    :::\n\n\n-   Ой\\\n    Почему в сравнении `NA == NA` получается `NA`?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    NA == NA\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] NA\n    ```\n    :::\n    :::\n\n\n-   Пропущенное значение - это отсутствие информации о чем-либо, следовательно, мы не можем сделать вывод, является ли отсутствие информации равным другому отсутствию.\n:::\n\n## Для выявления пропущенных значений используем функцию `is.na()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(vector_missed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n```\n:::\n:::\n\n\nТеперь с помощью логического отрицания (NOT, !) этого вектора можно отобрать не-пропущенные элементы:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(vector_missed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nvector_missed[!is.na(vector_missed)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nПосле этого можно делать интересующие операции над этим вектором, уже не беспокоясь о пропущенных значениях.\n\n## Чек-лист, что нужно знать после лекции\n\n-   Что такое переменные, как их создавать\n\n-   Как проверять переменные на равенство/неравенство, больше/меньше\n\n-   Правила индексации векторов\n\n-   Неявное приведение типов\n\n-   Работа с пропущенными значениями\n\n## Спасибо за внимание!\n\n::: columns\n::: {.column width=\"50%\"}\nПодписывайтесь на телеграм-канал о статистике:\n\n![](images/image-650896138.png){width=\"440\"}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}