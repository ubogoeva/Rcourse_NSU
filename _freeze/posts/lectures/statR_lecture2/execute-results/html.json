{
  "hash": "cfeb4366b4f8bbeaae63f05e26af57da",
  "result": {
    "markdown": "---\ntitle: \"Язык программирования R для анализа данных: лекция 2\"\nauthor: \"Елена Убогоева\"\nexecute: \n  echo: true\nformat: \n  revealjs:\n    slide-number: c/t\n    # mainfont: Arial\n    # fontsize: 14px\n    theme: [default, custom.scss]\n    # theme: [serif]\n    # mouse-wheel: true\n    auto-play-media: true\n    width: 1280\n    height: 720\neditor: visual\ndraft: true\n---\n\n\n## Повторим материал предыдущей лекции\n\n-   Переменные\n\n-   Векторы\n\n    -   Какие бывают типы векторов?\n\n    -   Неявное и явное приведение типов\n\n    -   Индексация векторов: по номеру индекса, логическим вектором\n\n-   Логические операторы: И, ИЛИ, НЕ\n\n-   Пропущенные значения:\n\n    -   Поиск пропущенных значений\n\n    -   Исключение пропущенных значений из вектора\n\n::: callout-important\nВажно! Значения в векторе могут быть **только** **одного** типа\n:::\n\n## План лекции\n\n-   Матрицы\n\n-   Списки\n\n-   Датафреймы\n\n-   Установка пакетов\n\n-   Условия, циклы (и особенности их использования)\n\n-   Векторизация как концепт, заменяющий циклы\n\n## Взаимоотношение типов данных в R\n\n::: columns\n::: {.column width=\"50%\"}\nМатрицы и списки (lists) являются расширением векторов, в свою очередь датафреймы объединяют свойства матриц и списков.\n\nПоэтому важно рассмотреть матрицы и списки перед разбором датафреймов.\n:::\n\n::: {.column width=\"50%\"}\n![](figures/matrix-list-df.png){width=\"468\"}\n:::\n:::\n\n## Матрицы\n\nПочти такое же понимание как и в линейной алгебре.\n\n::: columns\n::: {.column width=\"50%\"}\nСоздадим матрицу (укажем числа и количество строк):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- matrix(1:20, nrow = 5)\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n![](https://habrastorage.org/files/9ec/4ea/93a/9ec4ea93ab9a440e8a293a87df6dc303.gif){width=\"513\"}\n:::\n:::\n\nМожно сказать, что матрица - вектор, имеющий размерность 2 (строки и столбцы). Матрица, как и вектор, может содержать данные **только одного типа**. Бывают логические, числовые и строковые матрицы (последние редко).\n\n## Индексация матриц\n\nДля индексации используем квадратные скобки, матрицы имеют два измерения, следовательно, надо прописывать оба: `matrix[rows, columns]`\n\n::: incremental\n-   Поэлементное извлечение\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    M[1, 1] # извлечь элемент первой строки первого столбца матрицы\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    M[3, 4] # извлечь элемент третьей строки четвертого столбца матрицы\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 18\n    ```\n    :::\n    :::\n\n\n-   Извлечь целую строку или столбец\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    M[1, ] # извлечь первую строку\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]  1  6 11 16\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    M[, 4] # извлечь четвертый столбец\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 16 17 18 19 20\n    ```\n    :::\n    :::\n\n:::\n\n## Индексация матриц\n\nМожно индексировать целыми векторами:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM[1:3, ] # извлечь строки с первой по третью\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n```\n:::\n\n```{.r .cell-code}\nM[1:2, 2:3] # извлечь элементы первой-второй строк второго и третьего столбца\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    6   11\n[2,]    7   12\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nM[c(3, 1), ] # извлечь третью, первую строку\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    3    8   13   18\n[2,]    1    6   11   16\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"minimal\"}\nПравила индексации матриц нам очень понадобятся при работе с датафреймами\n:::\n\n## Замена элементов матриц\n\nТакже, как и при работе с векторами, часть элементов матрицы можно переписать.\n\nВспомним как для векторов:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nx[5] <- 100\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   1   2   3   4 100   6   7   8   9  10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nM[1:3, 2:4] <- 100\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1  100  100  100\n[2,]    2  100  100  100\n[3,]    3  100  100  100\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"minimal\"}\nМатрицы, как тип данных, используются при создании тепловых карт.\n:::\n\n## Списки (lists)\n\nСписок в R может содержать данные разного типа, даже другие списки. Список можно создать функцией `list()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist1 <- list(1:5, 'JoJo', TRUE)\nlist1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"JoJo\"\n\n[[3]]\n[1] TRUE\n```\n:::\n:::\n\n\n## Вложенные списки {style=\"font-size: 90%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_complex <- list(list1, c('this', 'is', 'complex list'))\nlist_complex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[[1]][[1]]\n[1] 1 2 3 4 5\n\n[[1]][[2]]\n[1] \"JoJo\"\n\n[[1]][[3]]\n[1] TRUE\n\n\n[[2]]\n[1] \"this\"         \"is\"           \"complex list\"\n```\n:::\n:::\n\n\nОбычно сложные вложенные списки никто намеренно не создает, но такой список может возникнуть например после парсинга сайтов или терминов генной онтологии.\n\n::: {.callout-note appearance=\"simple\"}\nПарсинг - сбор и структурирование данных с последующим анализом.\n:::\n\n## Структура листа {.smaller}\n\nУ сложных списков удобно посмотреть структуру, используя функцию `str()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list_complex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ :List of 3\n  ..$ : int [1:5] 1 2 3 4 5\n  ..$ : chr \"JoJo\"\n  ..$ : logi TRUE\n $ : chr [1:3] \"this\" \"is\" \"complex list\"\n```\n:::\n:::\n\n\nМожно создавать именованные списки:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list <- list(names = c('Joseph', 'Jotaro'), \n                   part = c(2, 3))\nnamed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"Joseph\" \"Jotaro\"\n\n$part\n[1] 2 3\n```\n:::\n:::\n\n\n## Индексация списков\n\nИндексация списков устроена несколько сложнее, чем векторов и матриц.\n\n::: columns\n::: {.column width=\"40%\"}\nДля начала попробуем индексацию по номеру\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist1[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nclass(list1[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nlength(list1[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nПолучился список длиной 1. Как же извлечь элемент списка не в виде списка?\n:::\n\n::: {.column width=\"60%\"}\nИллюстрация:\n\n![Взято из твиттера [\\@hadleywickham](https://twitter.com/hadleywickham)](https://i.stack.imgur.com/6Vwry.png){fig-align=\"left\" width=\"629\"}\n:::\n:::\n\n## Индексация списков\n\nЧтобы извлечь элемент списка не в виде списка можно использовать две квадратные скобки `sample_list[[1]]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist1[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nТакже можно использовать индексацию по имени: используя знак `$` или имя элемента в квадратных скобках в кавычках.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list$part\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list[['part']]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n:::\n\n\n## Создание новых элементов списка\n\nУдобнее всего создать новый элемент с помощью знака `$`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_list$year <- c(2012, 2014)\nnamed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"Joseph\" \"Jotaro\"\n\n$part\n[1] 2 3\n\n$year\n[1] 2012 2014\n```\n:::\n:::\n\n\n## Датафреймы\n\nДатафреймы - прямоугольные таблицы, которые могут содержать данные **разного типа**. Нам понадобится много работать с датафреймами.\n\nПопробуем создать датафрейм: функция `data.frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(names = c('Alexandra', 'Vlad', 'Ekaterina'), \n                 year = c(5, 3, 6),\n                 tasks = c(TRUE, FALSE, TRUE))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      names year tasks\n1 Alexandra    5  TRUE\n2      Vlad    3 FALSE\n3 Ekaterina    6  TRUE\n```\n:::\n:::\n\n\n::: {.callout-important appearance=\"simple\"}\nСтолбцы в датафрейме могут быть разных типов, однако в рамках одного столбца данные должны быть одного типа.\n:::\n\n## Индексация датафреймов\n\n::: columns\n::: {.column width=\"50%\"}\nИндексация датафреймов объединяет принципы индексации матриц и списков.\n:::\n\n::: {.column width=\"50%\"}\n![](figures/matrix-list-df.png)\n:::\n:::\n\n## Индексация датафреймов как матриц\n\nИспользуя квадратные скобки и индекс строк, колонок.\n\n::: columns\n::: {.column width=\"50%\"}\nПоэлементное извлечение:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[2, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Vlad\"\n```\n:::\n:::\n\n\nИзвлечение конкретных строк и столбцов\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[2:3, 1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      names year\n2      Vlad    3\n3 Ekaterina    6\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nИзвлечь целые строки или столбцы:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  names year tasks\n2  Vlad    3 FALSE\n```\n:::\n\n```{.r .cell-code}\ndf[, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE\n```\n:::\n:::\n\n:::\n:::\n\n::: callout-tip\nПри расстановке пробелов пользуемся правилами пунктуации: пробел ставится после запятой.\n:::\n\n## Индексация датафреймов как списков\n\nС помощью знака `$` или можно с помощью квадратных скобок\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alexandra\" \"Vlad\"      \"Ekaterina\"\n```\n:::\n\n```{.r .cell-code}\ndf$year\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3 6\n```\n:::\n\n```{.r .cell-code}\ndf[['names']]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alexandra\" \"Vlad\"      \"Ekaterina\"\n```\n:::\n\n```{.r .cell-code}\ndf$names == df[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n:::\n\n\n## Создание новых колонок\n\nПохоже на обращение к существующей, но пишем новое название и заполняем значениями.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$email <- c('email1', 'email2', 'email3')\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      names year tasks  email\n1 Alexandra    5  TRUE email1\n2      Vlad    3 FALSE email2\n3 Ekaterina    6  TRUE email3\n```\n:::\n:::\n\n\nПодробнее про работу с датафреймами еще поговорим в лекции по `tidyverse`.\n\n## Установка пакетов\n\nПакеты с CRAN-а скачиваются командой `install.packages('название пакета')`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('tidyverse')\n```\n:::\n\n\nПосле того, как мы скачали пакет, его необходимо подгружать каждый раз при работе командой `library(название пакета)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nИногда можно подгрузить одну функцию из пакета, используя оператор `::`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::case_when(<выражение>) # про это чуть дальше\n```\n:::\n\n\n## Установка пакетов не из CRAN\n\n-   С github-a или других репозиториев. Используется пакет `remotes`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    remotes::install_github('ggpattern')\n    ```\n    :::\n\n\n-   С [биокондактора](https://www.bioconductor.org/install/). Сначала нужно установить сам bioconductor - менеджер биологических пакетов.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    if (!require(\"BiocManager\", quietly = TRUE))\n        install.packages(\"BiocManager\")\n    ```\n    :::\n\n\n    Далее устанавливаем нужный пакет, хранящийся в биокондакторе:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    BiocManager::install(c(\"GenomicFeatures\", \"DESeq2\"))\n    ```\n    :::\n\n\n## Условные конструкции: `if`\n\nСинтаксис условной конструкции: `if (condition) true_action`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber <- 10\nif (number > 0) print('Положительное число')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Положительное число\"\n```\n:::\n:::\n\n\nЕсли выражение содержит несколько строчек, то необходимо использовать фигурные скобки.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber <- 10\nif (number > 0) {\n  print('Положительное число')\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Положительное число\"\n```\n:::\n:::\n\n\n## Условные конструкции: `if`, `else`\n\nДля описания действий в случае не выполнения условия используется оператор `else`\n\n`if (condition) true_action else false_action`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_number <- sample(-5:5, 1) # чтобы извлечь случайное число \n# из набора чисел от -5 до 5\nrandom_number\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nif (random_number > 0) {\n  print('Положительное число')\n} else {\n  print('Отрицательное число или ноль')\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Положительное число\"\n```\n:::\n:::\n\n\n::: {.callout-important appearance=\"simple\"}\nПоскольку команды в R исполняются построчно, важно, чтобы оператор `else` был на той же строке, что и закрывающая фигурная скобка `if`.\n:::\n\n## Векторизованный `if`\n\nОператор `if` на вход принимает только одно число. Что делать, если нам нужно проверить на какое-то условие целый вектор?\n\nВот это работать не будет (начиная с версии R 4.0):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (-3:3 > 0) print('Положительное число')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in if (-3:3 > 0) print(\"Положительное число\"): условие длиной > 1\n```\n:::\n:::\n\n\nДля операции над векторами используем функцию `ifelse()` из base R или `if_else()` из библиотеки `dplyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2:11\nifelse(x %% 2 == 0, 'Четное число', 'Нечетное число')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Четное число\"   \"Нечетное число\" \"Четное число\"   \"Нечетное число\"\n [5] \"Четное число\"   \"Нечетное число\" \"Четное число\"   \"Нечетное число\"\n [9] \"Четное число\"   \"Нечетное число\"\n```\n:::\n:::\n\n\n## `if_else()` из библиотеки dplyr\n\nОтличается чуть большей строгостью. Например, нельзя смешивать данные разных типов. Синтаксис такой же, как и в обычном `ifelse()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::if_else(2:11 %% 2 == 0, 'Четное', 'Нечетное')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Четное\"   \"Нечетное\" \"Четное\"   \"Нечетное\" \"Четное\"   \"Нечетное\"\n [7] \"Четное\"   \"Нечетное\" \"Четное\"   \"Нечетное\"\n```\n:::\n:::\n\n\nЧто произойдет, если мы используем разный тип данных для выражений выполненного условия и невыполненного?\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nif_else(-3:3 == 0, 0, 'Не ноль')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `if_else()`:\n! `false` must be a double vector, not a character vector.\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nifelse(-3:3 == 0, 0, 'Не ноль')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Не ноль\" \"Не ноль\" \"Не ноль\" \"0\"       \"Не ноль\" \"Не ноль\" \"Не ноль\"\n```\n:::\n:::\n\n:::\n:::\n\nЗначения, в случае, если условие выполнилось, и если не выполнилось, должны быть одного типа.\n\n## Оператор `case_when()`\n\nЕсли условий больше двух (или даже больше одного), на помощь приходит функция `case_when()` из пакета `dplyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::case_when(x > 0 ~ 'Положительное число', \n                 x == 0 ~ 'Ноль', \n                 x < 0 ~ 'Отрицательное число')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Положительное число\" \"Положительное число\" \"Положительное число\"\n [4] \"Положительное число\" \"Положительное число\" \"Положительное число\"\n [7] \"Положительное число\" \"Положительное число\" \"Положительное число\"\n[10] \"Положительное число\"\n```\n:::\n:::\n\n\nЗдесь тоже работает требование об одинаковом типе данных на значения после выполнения условия.\n\nПро пакет `dplyr` поговорим подробнее в лекции 4 про `tidyverse`.\n\n## Циклы\n\nЦиклы в R не рекомендованы к использованию, однако знать их синтаксис не повредит.\n\nСинтаксис:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (item in vector) {\n  <набор действий>\n}\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\nНапример:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:6) {\n  print(i ^ 2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n[1] 36\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nКонечно, возведение в степень куда проще сделать без цикла, но это учебный пример:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1:6) ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4  9 16 25 36\n```\n:::\n:::\n\n:::\n:::\n\n## Как использовать циклы правильно? {style=\"font-size: 90%\"}\n\nОдна из частых ошибок новичков при написании циклов - попасться в ловушку копирования.\n\nДопустим, мы написали цикл, в котором на каждой итерации вектор увеличивается на 1 элемент. В R каждый раз происходит копирование и выделение нового места под вектор и это *extremely slow*.\n\nНужно заранее создать вектор нужного размера, чтобы выделить для него память и не создавать копий (подробнее [здесь](https://adv-r.hadley.nz/perf-measure.html#memory-profiling), [здесь](https://adv-r.hadley.nz/perf-improve.html#avoid-copies)).\n\nПлохо:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2,4\"}\nvalues <- 11:20\ncube_values <- vector()\nfor (i in 1:length(values)) {\n  cube_values <- c(cube_values, values[i] ^ 3) # копирование на каждой итерации\n}\ncube_values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1331 1728 2197 2744 3375 4096 4913 5832 6859 8000\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n::: columns\n::: {.column width=\"50%\"}\nЛучше создать вектор нужного размера перед циклом:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1,2\"}\ncube_values <- vector('numeric', \n  length = length(values)) \nfor (i in 1:length(values)) {\n  cube_values[i] <- values[i] ^ 3\n}\ncube_values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1331 1728 2197 2744 3375 4096 4913 5832 6859 8000\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nСовсем правильно использовать `seq_along():`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|3\"}\ncube_values <- vector(mode = 'numeric', \n                      length = length(values))\nfor (i in seq_along(values)) {\n  cube_values[i] <- values[i] ^ 3\n}\ncube_values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1331 1728 2197 2744 3375 4096 4913 5832 6859 8000\n```\n:::\n:::\n\n:::\n:::\n\nРекомендуется использовать `seq_along()`, чтобы наверняка избежать проблемы с пустым вектором.\n\nПравильно конечно с точки зрения циклов, так как есть ряд альтернативных рекомендуемых подходов вместо них.\n\n::: callout-tip\nСовет от Соника: не использовать циклы вообще👍\n:::\n\n## Как использовать циклы правильно?\n\nВторая распространенная ошибка: проблема с `1:length(vector)`\n\nСуть в том, что мы можем получить неожиданный результат, если вектор пустой, поскольку оператор `:` работает и в убывающую сторону (то есть получается 1:0).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nempty_vector <- vector()\nfor (i in 1:length(empty_vector)) {\n  print(i ^ 2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 0\n```\n:::\n:::\n\n\nПохоже, что мы ожидали не этого. Чтобы этого избежать, вместо `1:length()` используем `seq_along()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(empty_vector)) {\n  print(i ^ 2)\n}\n```\n:::\n\n\n## Векторизация - вместо циклов\n\nВообще правильный подход - использовать векторизацию вместо циклов.\n\nВекторизация - это применение какой-либо функции над каждым элементом вектора.\n\nМожно записать идею в математической нотации:\n\nПусть *f()* - векторизованная функция. Тогда $y = f(x)$ означает, что мы применяем функцию *f()* к каждому элементу вектора `x`, на выходе получаем вектор `y` такой же длины как вектор `x`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvectorized_example <- 1:10\nsqrt(vectorized_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\nФраза *векторизованная функция* означает, что операции производятся сразу над каждым элементом вектора.\n:::\n\n## Еще немного векторизации\n\nБольшинство базовых функций в R векторизованы по умолчанию, и если они применимы к одному элементу, то скорее всего будут применимы и к целому вектору. Например, уже разобранные операторы возведения в степень `^`, квадратный корень, логарифм и тд.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1:10) ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n:::\n\n```{.r .cell-code}\nlog(1:10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.000000 1.000000 1.584963 2.000000 2.321928 2.584963 2.807355 3.000000\n [9] 3.169925 3.321928\n```\n:::\n:::\n\n\nНе являются векторизованными: `mean()`, `sum()`. Как думаете, почему?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(1:100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50.5\n```\n:::\n\n```{.r .cell-code}\nsum(1:100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5050\n```\n:::\n:::\n\n\n## Применение векторизации {style=\"font-size: 90%\"}\n\nНапример, нам нужно посчитать средние значения в списке, а функция `mean()` не векторизована. Что делать? Использовать функции семейства `*apply()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_values <- list(rnorm(10), rnorm(10, mean = 5, sd = 2),\n                    rnorm(10, mean = 10, sd = 3))\nlist_values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1]  2.07983997  0.30414912  0.77383315 -0.63807175  0.28889034  0.23361007\n [7] -0.09532000  0.66944603  0.08062912 -1.00874211\n\n[[2]]\n [1] 3.907073 2.732515 2.606927 5.805492 4.360885 3.701539 6.144990 5.664932\n [9] 7.398804 7.892041\n\n[[3]]\n [1]  8.188229  6.341163  7.984042 10.407791 11.736316 11.862250  8.177342\n [8]  6.138101 15.692003 16.317226\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\n`rnorm()` генерирует числа из нормального распределения со среднем 0 и стандартным отклонением 1 (по умолчанию).\n:::\n\n------------------------------------------------------------------------\n\n\n::: {.cell output-location='default'}\n\n```{.r .cell-code}\nlapply(list_values, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.2688264\n\n[[2]]\n[1] 5.021519\n\n[[3]]\n[1] 10.28445\n```\n:::\n:::\n\n\n## Спасибо за внимание!\n\n::: columns\n::: {.column width=\"50%\"}\nПодписывайтесь на телеграм-канал о статистике:\n\n![](images/image-650896138.png){width=\"440\"}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}