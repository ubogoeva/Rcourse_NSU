{
  "hash": "f0510f514d7ffecd9921a345d1e9fb2c",
  "result": {
    "markdown": "---\ntitle: \"Решения задач по первой лекции\"\ndate: '02 March 2023'\nauthor: 'Elena U'\nexecute: \n  echo: true\ncategories: task\ndraft: true\n---\n\n\nМожно проверить свое решение и сравнить с моим.\n\nРассчитано на самопроверку: ваша задача написать такой код, чтобы совпал с моим правильным ответом. Плюс есть еще несколько заданий на подумать и вспомнить материал лекции.\n\nЕсли вдруг найдутся ошибки/опечатки, пишите на почту `e.ubogoeva@alumni.nsu.ru` или в телеграм. Вопросы по заданиям также можно писать на почту или в телеграм, телеграм чуть предпочтительнее.\n\n## Калькулятор\n\n-   Разделите числа `2583`, `5971`, `2946`, `5783` на `7`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2583 / 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 369\n```\n:::\n\n```{.r .cell-code}\n5971 / 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 853\n```\n:::\n\n```{.r .cell-code}\n2946 / 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 420.8571\n```\n:::\n\n```{.r .cell-code}\n5783 / 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 826.1429\n```\n:::\n:::\n\n\n-   Посчитайте остаток от деления этих же чисел на `7`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2583 %% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n5971 %% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n2946 %% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n5783 %% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n-   А целую часть от деления (числа те же)?\\\n    Подсказка: справку по арифметическим операторам можно вызвать, набрав например ?\\`+\\` в консоли или просто погуглить: *оператор целочисленного деления R*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2583 %/% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 369\n```\n:::\n\n```{.r .cell-code}\n5971 %/% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 853\n```\n:::\n\n```{.r .cell-code}\n2946 %/% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 420\n```\n:::\n\n```{.r .cell-code}\n5783 %/% 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 826\n```\n:::\n:::\n\n\n-   Посчитайте квадратный корень из числа 289 двумя разными способами\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(289)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 17\n```\n:::\n\n```{.r .cell-code}\n289 ^ 0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 17\n```\n:::\n:::\n\n\n-   Посчитайте логарифм по основанию `7` от числа `96889010407`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(96889010407, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n:::\n\n\n-   Теперь натуральный логарифм от числа `10`, результат умножить на `6`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10) * 6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13.81551\n```\n:::\n:::\n\n\n## Работа с векторами\n\n-   Создайте вектор из чисел 5, 203, 11\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(5, 203, 11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   5 203  11\n```\n:::\n:::\n\n\n-   Создайте вектор из чисел от 314 до 335\n\n\n::: {.cell}\n\n```{.r .cell-code}\n314:335\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332\n[20] 333 334 335\n```\n:::\n:::\n\n\n-   Создайте вектор чисел от 20 до 2. Подсказка: оператор `:` работает и для создания последовательностей с шагом -1/\n\n\n::: {.cell}\n\n```{.r .cell-code}\n20:2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2\n```\n:::\n:::\n\n\n-   Создайте вектор чисел от 20 до 2 с шагом -2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(20, 2, -2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 20 18 16 14 12 10  8  6  4  2\n```\n:::\n:::\n\n\n-   Создайте вектор, состоящий из двадцати единиц\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rep(1, 20)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n    ```\n    :::\n    :::\n\n\n-   Создайте вектор 1 1 1 2 2 2 3 3 3. Подсказка: чтобы узнать как это можно сделать, посмотрите справку функции `rep()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rep(1:3, each = 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1 1 1 2 2 2 3 3 3\n    ```\n    :::\n    :::\n\n\n-   А теперь вектор 1 1 2 2 3 3 1 1 2 2 3 3 1 1 2 2 3 3 (если что непонятно - смотрим справку и гуглим)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rep(1:3, each = 2, times = 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] 1 1 2 2 3 3 1 1 2 2 3 3 1 1 2 2 3 3\n    ```\n    :::\n    :::\n\n\n## Логические операторы\n\n-   Проверьте на равенство: остаток от деления 257 на 6 и число 5\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 == 257 %% 6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n-   Проверьте на равенство число 2 и квадратный корень из 2 в квадрате.\\\n    Ответ убил:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    2 == sqrt(2) ^ 2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] FALSE\n    ```\n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    2 == sqrt(2) ^ 2\n    ```\n    :::\n\n\n    Почему это произошло, можно почитать [здесь](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f). Такой прикол существует не только в R, а характерен для любого языка программирования, поскольку дробные числа в компьютере хранятся с ограниченной (хоть и достаточно большой) точностью. Для проверки на равенство такого рода можно использовать функцию `all.equal()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    all.equal(2, sqrt(2) ^ 2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] TRUE\n    ```\n    :::\n    :::\n\n\n    ::: callout-note\n    Все дело в том, что числа в компьютере записываются в виде степеней двойки.\n    :::\n\n-   Сколько чисел, делящихся на 3 без остатка, в векторе чисел от 1 до 80?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum(1:80 %% 3 == 0)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 26\n    ```\n    :::\n    :::\n\n\n## Индексация векторов\n\n-   Создайте вектор x, состоящий из чисел с 2 до 20 с шагом 2. Извлеките 2, 5, 7 элемент\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(2, 20, 2)\nx[c(2, 5, 7)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 10 14\n```\n:::\n:::\n\n\n-   Создайте вектор x, состоящий из чисел с 2 до 20 с шагом 2. Извлеките каждый третий элемент.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- seq(2, 20, 2)\n    x[seq(3, length(x), 3)]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]  6 12 18\n    ```\n    :::\n    :::\n\n\n-   Индесация по условию. Извлеките все числа, кратные 9, в векторе чисел от 1 до 100.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- 1:100\n    x[x %% 9 == 0]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1]  9 18 27 36 45 54 63 72 81 90 99\n    ```\n    :::\n    :::\n\n\n-   Извлеките все числа, больше или равные нулю в векторе -4 -2 0 2 4\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- seq(-4, 4, 2)\n    x[x >= 0]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0 2 4\n    ```\n    :::\n    :::\n\n\n## Приведение типов\n\n-   Какой будет тип у вектора `c(TRUE, 2, 'gene')`? И почему?\\\n    **Ответ:** character vector, поскольку этот тип является наиболее общим у приведенных элементов вектора\n\n-   Вспомните, в каком порядке должно идти приведение типов.\\\n    **Ответ:** logical \\> integer \\> numeric \\> character\n\n-   Какими функциями можно превратить вектор в нужный тип?\\\n    **Ответ:** например, `as.integer()`. В общем случае as.\\<нужный_тип\\>\n\n## Пропущенные значения\n\n-   Уберите пропущенные значения из вектора\\\n    `missed_values <- c(NA, 1:3, NA, 7, 10, NA, NA, NA, 8, 5, 7)`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    missed_values <- c(NA, 1:3, NA, 7, 10, NA, NA, NA, 8, 5, 7)\n    missed_values[!is.na(missed_values)]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]  1  2  3  7 10  8  5  7\n    ```\n    :::\n    :::\n\n\n-   Посчитайте среднее в этом векторе двумя разными способами\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mean(missed_values[!is.na(missed_values)])\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 5.375\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    mean(missed_values, na.rm = TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 5.375\n    ```\n    :::\n    :::\n\n\n-   Почему при сравнении `NA == NA` получается `NA`?\\\n    **Ответ:** Мы не можем сделать вывод, равно ли одно неизвестное другому неизвестному\n\n-   Чем плохи пропущенные значения?\\\n    **Ответ:** Мешают вычислять описательные статистики, невозможно делать сравнения `==`, `<`, `>`, некоторые функции просто не работают с пропущенными значениями.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}