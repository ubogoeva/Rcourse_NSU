{
  "hash": "0a600daeb677eca2f5c602eb2acfb29a",
  "result": {
    "markdown": "---\ntitle: \"Решения заданий по второй лекции\"\ndate: '07 March 2023'\nauthor: 'Elena U'\nexecute: \n  echo: true\neditor: visual\ncategories: task\ndraft: true\n---\n\n\nСоставлены в формате задание - ответ к нему.\n\nРассчитано на самопроверку: ваша задача написать такой код, чтобы совпал с моим правильным ответом. Плюс есть еще несколько заданий на подумать и вспомнить материал лекции.\n\n**Не стесняйтесь гуглить**, это необходимо для решения многих задач в программировании, которые могут встретиться в реальной жизни.\n\nЕсли вдруг найдутся ошибки/опечатки, пишите на почту `e.ubogoeva@alumni.nsu.ru` или в телеграм. Вопросы по заданиям также можно писать на почту или в телеграм, телеграм чуть предпочтительнее.\n\n## Матрицы\n\n-   Создайте матрицу `A`, состоящую из единиц и имеющую 4 колонки и 4 строки:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    A <- matrix(1, 4, 4)\n    A\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n         [,1] [,2] [,3] [,4]\n    [1,]    1    1    1    1\n    [2,]    1    1    1    1\n    [3,]    1    1    1    1\n    [4,]    1    1    1    1\n    ```\n    :::\n    :::\n\n\n-   Замените третью строку матрицы A на числа 5, 6, 7, 8\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    A[3, ] <- c(5, 6, 7, 8)\n    A\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n         [,1] [,2] [,3] [,4]\n    [1,]    1    1    1    1\n    [2,]    1    1    1    1\n    [3,]    5    6    7    8\n    [4,]    1    1    1    1\n    ```\n    :::\n    :::\n\n\n-   Извлеките четвертую колонку этой матрицы\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    A[, 4]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1 1 8 1\n    ```\n    :::\n    :::\n\n\n-   Создайте матрицу `M` из чисел от 21 до 40 размером 4 строки и 5 столбцов.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    M <- matrix(21:40, nrow = 4, ncol = 5)\n    M\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n         [,1] [,2] [,3] [,4] [,5]\n    [1,]   21   25   29   33   37\n    [2,]   22   26   30   34   38\n    [3,]   23   27   31   35   39\n    [4,]   24   28   32   36   40\n    ```\n    :::\n    :::\n\n\n-   Замените в матрице `M` четные значения словом \"Четное\", а нечетные словом \"Нечетное\".\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ifelse(M %% 2 == 0, 'Четное', 'Нечетное')\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n         [,1]       [,2]       [,3]       [,4]       [,5]      \n    [1,] \"Нечетное\" \"Нечетное\" \"Нечетное\" \"Нечетное\" \"Нечетное\"\n    [2,] \"Четное\"   \"Четное\"   \"Четное\"   \"Четное\"   \"Четное\"  \n    [3,] \"Нечетное\" \"Нечетное\" \"Нечетное\" \"Нечетное\" \"Нечетное\"\n    [4,] \"Четное\"   \"Четное\"   \"Четное\"   \"Четное\"   \"Четное\"  \n    ```\n    :::\n    :::\n\n\n## Списки\n\n-   Создайте список `list1`, первый элемент: числовой вектор от 11 до 77 с шагом 3, второй элемент: буквы строчные английского алфавита - это встроенный набор `letters`, третий элемент: вектор `TRUE`, `FALSE`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list1 <- list(seq(11, 77, 3), letters, c(TRUE, FALSE))\n    list1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n     [1] 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77\n    \n    [[2]]\n     [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n    [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n    \n    [[3]]\n    [1]  TRUE FALSE\n    ```\n    :::\n    :::\n\n\n-   Извлеките второй элемент списка в виде вектора\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list1[[2]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n    [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n    ```\n    :::\n    :::\n\n\n-   Извлеките четвертый элемент вектора первого элемента списка\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list1[[1]][4]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 20\n    ```\n    :::\n    :::\n\n\n-   Создайте новый элемент в списке, назовите его `double_vector` и заполните его первым элементом списка, умноженного на 2\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list1$double_vector <- list1[[1]] * 2\n    list1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n     [1] 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77\n    \n    [[2]]\n     [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n    [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n    \n    [[3]]\n    [1]  TRUE FALSE\n    \n    $double_vector\n     [1]  22  28  34  40  46  52  58  64  70  76  82  88  94 100 106 112 118 124 130\n    [20] 136 142 148 154\n    ```\n    :::\n    :::\n\n\n-   Извлеките элемент `double_vector` двумя разными способами\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list1$double_vector\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1]  22  28  34  40  46  52  58  64  70  76  82  88  94 100 106 112 118 124 130\n    [20] 136 142 148 154\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    list1[['double_vector']]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1]  22  28  34  40  46  52  58  64  70  76  82  88  94 100 106 112 118 124 130\n    [20] 136 142 148 154\n    ```\n    :::\n    :::\n\n\n-   Извлеките 1, 3, 5, 7 элементы вектора double_vector\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list1$double_vector[c(1, 3, 5, 7)]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 22 34 46 58\n    ```\n    :::\n    :::\n\n\n-   Замените пятый элемент `double_vector` на 100. Правила такие же как при замене элементов векторов\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"true\"}\n    list1$double_vector[5] <- 100\n    list1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n     [1] 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77\n    \n    [[2]]\n     [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n    [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n    \n    [[3]]\n    [1]  TRUE FALSE\n    \n    $double_vector\n     [1]  22  28  34  40 100  52  58  64  70  76  82  88  94 100 106 112 118 124 130\n    [20] 136 142 148 154\n    ```\n    :::\n    :::\n\n\n-   Создайте отдельный список `small_list` из первого и третьего элемента списка `list1`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    small_list <- list1[c(1, 3)]\n    small_list\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n     [1] 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77\n    \n    [[2]]\n    [1]  TRUE FALSE\n    ```\n    :::\n    :::\n\n\n-   Составьте список `list2`, состоящий из заглавных букв английского алфавита (LETTERS) номером 10, 15, 10, 15.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list2 <- LETTERS[c(10, 15, 10, 15)]\n    list2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"J\" \"O\" \"J\" \"O\"\n    ```\n    :::\n    :::\n\n\n-   Объедините `list1` и `list2` в список `list_whole`, проверьте тип данных, выведите структуру.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list_whole <- list(list1, list2)\n    class(list_whole)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"list\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    str(list_whole)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    List of 2\n     $ :List of 4\n      ..$              : num [1:23] 11 14 17 20 23 26 29 32 35 38 ...\n      ..$              : chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n      ..$              : logi [1:2] TRUE FALSE\n      ..$ double_vector: num [1:23] 22 28 34 40 100 52 58 64 70 76 ...\n     $ : chr [1:4] \"J\" \"O\" \"J\" \"O\"\n    ```\n    :::\n    :::\n\n\n## Датафреймы\n\n-   Создадим датафрейм `df`, первая колонка: числа 10, 12, 15, вторая колонка вектор TRUE, FALSE, TRUE, третья колонка любой строковый вектор\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df <- data.frame(c(10, 12, 15), c(TRUE, FALSE, TRUE),\n                     letters[1:3])\n    df\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n      c.10..12..15. c.TRUE..FALSE..TRUE. letters.1.3.\n    1            10                 TRUE            a\n    2            12                FALSE            b\n    3            15                 TRUE            c\n    ```\n    :::\n    :::\n\n\n-   Лучше создать с именами:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df <- data.frame(values = c(10, 12, 15), logi = c(TRUE, FALSE, TRUE), character = letters[1:3])\n    df\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n      values  logi character\n    1     10  TRUE         a\n    2     12 FALSE         b\n    3     15  TRUE         c\n    ```\n    :::\n    :::\n\n\n-   Также для переименования можно использовать функцию `colnames()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    colnames(df) <- c('name1', 'name2', 'name3')\n    df\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n      name1 name2 name3\n    1    10  TRUE     a\n    2    12 FALSE     b\n    3    15  TRUE     c\n    ```\n    :::\n    :::\n\n\n-   Извлеките 1, 2, 3 строки 5, 6, 9 колонки датасета `mtcars` (встроен в R, достаточно набрать `mtcars`).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mtcars[1:3, c(5, 6, 9)]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n                  drat    wt am\n    Mazda RX4     3.90 2.620  1\n    Mazda RX4 Wag 3.90 2.875  1\n    Datsun 710    3.85 2.320  1\n    ```\n    :::\n    :::\n\n\n## Установка пакетов\n\n-   Установите пакет `ggplot2` (пакет с CRAN-а для графиков)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    install.packages(\"ggplot2\")\n    ```\n    :::\n\n\n-   Загрузите пакет `ggplot2`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(ggplot2)\n    ```\n    :::\n\n\n-   Задание со звездочкой (на способность гуглить): удалите (unload) пакет `ggplot2` из окружения. Это редко, но иногда может понадобиться, при загрузке ненужного пакета. Однако, я рекомендую перезапустить RStudio комбинацией клавиш Ctrl+Shift+F10, и после этого загрузить уже только нужные пакеты.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    detach(package:ggplot2)\n    ```\n    :::\n\n\n## Условия\n\n-   Извлечь случайное число из набора 0.00015, 0.6, 0.056, 0.02, если число \\< 0.05, вывести в консоль \"p-value \\< 0.05\", иначе вывести \"p-value не значимо\".\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    value <- sample(c(0.00015, 0.6, 0.02, 0.056), 1)\n    if (value < 0.05) {\n      print('p-value < 0.05')\n    } else {\n      print(\"p-value не значимо\")\n    }\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"p-value не значимо\"\n    ```\n    :::\n    :::\n\n\n::: callout-tip\nНапоминаю, что для извлечения случайных чисел используется функция `sample()`\n:::\n\n## Циклы\n\nНа циклы заданий не будет, потому что все, что я смогла придумать легко решается без циклов. Совет от соника: не использовать циклы.\n\n## Векторизация\n\n-   Создайте вектор p, состоящий из значений 4, 5, 6, 7, и вектор q, состоящий из 0, 1, 2, 3.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p <- c(4, 5, 6, 7)\n    q <- c(0, 1, 2, 3)\n    p\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 4 5 6 7\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    q\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0 1 2 3\n    ```\n    :::\n    :::\n\n\n-   Посчитайте поэлементную сумму векторов p и q:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p + q\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]  4  6  8 10\n    ```\n    :::\n    :::\n\n\n-   Посчитайте поэлементную разницу p и q:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p - q\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 4 4 4 4\n    ```\n    :::\n    :::\n\n\n-   Поделите каждый элемент вектора p на соответствующий ему элемент вектора q:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    p / q\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]      Inf 5.000000 3.000000 2.333333\n    ```\n    :::\n    :::\n\n\n-   Создайте вектор, в котором будут содержаться первые 20 степеней двойки.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    2 ^ (1:20)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1]       2       4       8      16      32      64     128     256     512\n    [10]    1024    2048    4096    8192   16384   32768   65536  131072  262144\n    [19]  524288 1048576\n    ```\n    :::\n    :::\n\n\n-   Посчитайте сумму чисел, кратных 3 ИЛИ кратных 5 в наборе чисел от 1 до 100\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- 1:100\n    sum(x[x %% 3 == 0 | x %% 5 == 0])\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 2418\n    ```\n    :::\n    :::\n\n\n-   Найдите сумму всех простых чисел от 1 до 100, где 1 не является простым. Если не получается решить задание сейчас, лучше подождать следующей лекции, разберем более подробно векторизацию и работу с функциями семейства `*apply()` и создание собственных функций.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    is_prime <- function(x) {\n      if (x == 1) return(FALSE)\n      if (x == 2) return(2)\n      if (sum(x %% 2:(x-1) == 0) == 0) return(x) else return(FALSE)\n    }\n    sum(sapply(1:100, is_prime))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1060\n    ```\n    :::\n    :::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}