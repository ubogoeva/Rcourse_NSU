{
  "hash": "4298367539bb8855619d526f243ab2f1",
  "result": {
    "markdown": "---\ntitle: \"Решения по третьей лекции\"\ndate: '20 March 2023'\nauthor: 'Elena U'\nexecute: \n  echo: true\neditor: visual\ncategories: task\ndraft: true\n---\n\n\nСоставлены в формате задание - ответ к нему.\n\nРассчитано на самопроверку: ваша задача написать такой код, чтобы совпал с моим правильным ответом. Плюс есть еще несколько заданий на подумать и вспомнить материал лекции.\n\n**Не стесняйтесь гуглить**, это необходимо для решения многих задач в программировании, которые могут встретиться в реальной жизни.\n\nЕсли вдруг найдутся ошибки/опечатки, пишите на почту `e.ubogoeva@alumni.nsu.ru` или в телеграм. Вопросы по заданиям также можно писать на почту или в телеграм, телеграм чуть предпочтительнее.\n\n## Создание функций\n\n-   Создайте функцию `plus_two()`, которая принимает число и возвращает это же число + 2.\n\n-   Проверьте функцию `plus_two()` на числе 40\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    plus_two <- function(x) x + 2\n    plus_two(40)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 42\n    ```\n    :::\n    :::\n\n\n-   Создайте функцию, которая вычисляет площадь круга на основании радиуса и посчитайте площадь круга радиусом 5 (в R есть встроенная константа `pi`).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    circle_area <- function(r) pi*r^2\n    circle_area(5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 78.53982\n    ```\n    :::\n    :::\n\n\n-   Создайте функцию, которая переводит градусы Цельсия в Фаренгейта. Проверьте на значениях -100, -40 и 0, что функция работает корректно\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    cels2far <- function(x) x * 1.8 + 32\n    cels2far(c(-100, -40, 0))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] -148  -40   32\n    ```\n    :::\n    :::\n\n\n-   Найдите сумму всех простых чисел от 1 до 100, где 1 не является простым, по возможности используя подход `purrr::map()`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(purrr)\n    is_prime <- function(x) {\n      if (x == 1) return(FALSE)\n      if (x == 2) return(2)\n      if (!any(x %% 2:(x-1) == 0)) return(x) else return(FALSE)\n    }\n    sum(map_dbl(1:100, is_prime))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1060\n    ```\n    :::\n    :::\n\n\n-   Проверьте, является ли число 2023 простым\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    is_prime(2023)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] FALSE\n    ```\n    :::\n    :::\n\n\n-   Используя функцию `is_prime()`, создайте функцию `prime_numbers()`, которая выводит все простые числа перед заданным числом. Проверьте на числах 200, 1000.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    prime_numbers <- function(x) {\n      (1:x)[map_dbl(1:x, is_prime) != 0]\n    }\n    prime_numbers(200)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1]   2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67\n    [20]  71  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151 157 163\n    [39] 167 173 179 181 191 193 197 199\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    prime_numbers(1000)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n      [1]   2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61\n     [19]  67  71  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151\n     [37] 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251\n     [55] 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359\n     [73] 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463\n     [91] 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593\n    [109] 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701\n    [127] 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827\n    [145] 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953\n    [163] 967 971 977 983 991 997\n    ```\n    :::\n    :::\n\n\n    ## Функции семейства `apply()`\n\n-   Создайте список `list3`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list3 <- list(\n      a = 1:5,\n      b = 0:20,\n      c = 4:24,\n      d = 6:3,\n      e = 6:25\n      )\n    ```\n    :::\n\n\n-   Посчитайте максимальное значение по каждому элементу списка. Ответ получите в виде списка и в виде вектора.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    lapply(list3, max)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    $a\n    [1] 5\n    \n    $b\n    [1] 20\n    \n    $c\n    [1] 24\n    \n    $d\n    [1] 6\n    \n    $e\n    [1] 25\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    map_dbl(list3, max)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     a  b  c  d  e \n     5 20 24  6 25 \n    ```\n    :::\n    :::\n\n\n-   Посчитайте максимальное значение в каждой колонке датасета `mtcars`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    apply(mtcars, 2, max)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n        mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n     33.900   8.000 472.000 335.000   4.930   5.424  22.900   1.000   1.000   5.000 \n       carb \n      8.000 \n    ```\n    :::\n    :::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}